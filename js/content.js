var myText = [{
    h2: 'Введение',
    p: [{
        h3: 'Введение в JavaScript',
        p: '1.Введение в JavaScript дает нам общее понятие о создании, общей истории и развити JavaScript'
    }, {
        h3: 'Справочники и спецификации',
        p: '2.Подраздел справочники и спецификации дает нам информацию о том, какие особенности у каких браузеров и где можно найти корректную документацию касаемо JavaScript'

    }, {
        h3: 'Редакторы для кода',
        p: '3.В пункте Редакторы для кода нам представляется возможность ознакомиться с редакторами кода и ссылками на оф. страницы для скачивания.'

    }, {

        h3: "Консоль разработчика",
        p: "4.Пункт Консоль разработчика в кратце рассказывает нам на что стоит обратить внимание при проверке кода через консоль."
    }]
}, {
    h2: "Основы JavaScript",
    p: [{

        h3: "Привет мир!",
        p: "В данной статье нас знакомяс с особенностями месторасположения тега script и корректным размещением коментариев и тд."

    }, {
        h3: "Внешние скрипты, порядок исполнения",
        p: "Данная статья обучает нас подключению внешних скриптов и корректирует нас в их особенностях и различиях при загрузке на страницу а так же рассказывает, как они непосредственно влияют на саму загрузку страницы"

    }, {
        h3: "Структура кода ",
        p: "Данная статья обучит нас как корректнее делать разметку кода, переносы и разбитие на строки"

    }, {
        h3: "Современный стандарт, use strict",
        p: "Use strict строка- дает нам возможность писать более современный код, но в то же время имеет свои особенности в использовании..."

    }, {
        h3: "Переменные",
        p: "На мой взгляд-одна из важнейших статей в данном разделе! Благодаря ей мы более детально поймем как работать с переменными, заполнять их информацией и использовать ее в будущем."

    }, {
        h3: "Правильный выбор имени переменной",
        p: "Правильный выбор имени переменных-одно из основных базовых  пониманий того, что в ней будет храниться либо для чего она может быть использована"

    }, {
        h3: "Шесть типов данных, typeof",
        p: "В данной статье нас в кратце ознакамливают с 5 основными примитивными  типами данных и обьектами"

    }, {
        h3: "Операторы",
        p: "Исходя из школьных программ все мы помним про математические елементы вычисления. Но в данной статье афтор открывает нам их новые возможности и раскрывает секреты использования в програмировании"

    }, {
        h3: "Условные операторы: if,?",
        p: "Данная статья обучает нас различиям методов использования операторов а так же дает нам возможность понять, как грамотно выстроить логическую цепочку действий при различных ответах(либо без них)."

    }, {
        h3: "Функции",
        p: "Данный ряд статей нам рассказывает о том, как грамотно создавать и использовать функции и с их помощью делать клиентскую сторону более динамичной."
    }]
}, {
    h2: "Качество кода",
    p: [{
        h3: "Отладка в chrome",
        p: "В данном пункте нам рассказывается о корректном тестировании кода, его шифровании и отладке в браузере. О том, куда стоит обратить внимание при работе с данным браузером."
    }, {
        h3: "Советы по стилю кода",
        p: "Мы переходим к стилю кода и его корректному написанию. В этом разделе нам предоставят таблицу со всеми нареканиями и замечаниями которые могут навредить нашему написанию кода и его формированию(дальнейшему использованию) на странице"
    }, {
        h3: "Как писать неподдерживаемый код?",
        p: "Для написания неподдерживаемого кода нужно усложнить его понятность для окружающих(уловки на эту тему указаны в данном разделе) а так же нам дается краткая екскурсия того, как этот код писать так, чтоб он был понятен только вам"
    }, {
        h3: "Автоматические тесты при помощи chai и mocha",
        p: "С данной главой я рекомендовал бы ознакомиться в начале своей деятельности как програмиста. Ведь писочницу можно использовать как тесты (которые гарантируют правильность кода),документацию по функциям и описанию их конкретных задач"
    }]
}, {
    h2: "Структуры данных",
    p: [{
        h3: "Введение в методы и свойства",
        p: "Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку». К примеру .length укажет нам длинну масива а str.toUpperCase() вернет строку в ВЕРХНЕМ РЕГИСТРЕ, num.toFixed(n) округлитель чисел в котором num-число а n количество цифр после запятой"
    }, {
        h3:"Числа",
        p:"Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа, В JavaScript существует числовое значение бесконечность Infinity.\n" +
        "Ошибка вычислений дает NaN Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p"
    },{
        h3:"Строки",
        p:"\\b\tBackspace\n" +
        "\\f\tForm feed\n" +
        "\\n\tNew line\n" +
        "\\r\tCarriage return\n" +
        "\\t\tTab" +
        "Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний" +
        "Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция])"
    },{
        h3:"Обьекты как ассоциальные массивы",
        p:"Доступ к элементам осуществляется:\n" +
		"Напрямую по ключу obj.prop = 5\n" +
		"Через переменную, в которой хранится ключ\n" +
		"Удаление ключей: delete obj.name"
    },{
        h3:"Объекты: перебор свойств",
        p:"Цикл по ключам: for (key in obj)\n" +
		"Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах)\n" +
		"Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +"
    },{
        h3:"Объекты: передача по ссылке",
        p:"Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.\n" +
		"Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.\n" +
		"Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью."
    },{
        h3:"Массивы с числовыми индексами",
        p:"length – длина массива. Если точнее, то последний индекс массива плюс 1. Если её уменьшить вручную, то массив укоротится. Если length больше реального количества элементов, то отсутствующие элементы равны undefined \n" +
		"arr.push(элемент1, элемент2...) добавляет элементы в конец. \n" +
		"var elem = arr.pop() удаляет и возвращает последний элемент \n" +
		"arr.unshift(элемент1, элемент2...) добавляет элементы в начало. \n" +
		"var elem = arr.shift() удаляет и возвращает первый элемент \n" +
		"Эти операции перенумеровывают все элементы, поэтому работают медленно"
    },{
        h3:"Массивы: методы",
        p:"push/pop, shift/unshift, splice – для добавления и удаления элементов.\n" +
		"join/split – для преобразования строки в массив и обратно.\n" +
		"slice – копирует участок массива.\n" +
		"sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.\n" +
		"reverse – меняет порядок элементов на обратный.\n" +
		"concat – объединяет массивы.\n" +
		"indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).\n" +
		"Дополнительно: Object.keys(arr) возвращает массив свойств объекта."
    },{
		h3:"Массив: перебирающие методы",
		p:"forEach – для перебора массива.\n" +
		"filter – для фильтрации массива.\n" +
		"every/some – для проверки массива.\n" +
		"map – для трансформации массива в массив.\n" +
		"reduce/reduceRight – для прохода по массиву с вычислением значения."
	},{
		h3:"Псевдомассив аргументов(arguments)",
		p:"Полный список аргументов, с которыми вызвана функция, доступен через arguments.\n" +
        "Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет.\n" +
        "В старом стандарте было свойство arguments.callee со ссылкой на текущую функцию, а также свойство arguments.callee.caller, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при use strict обращение к ним приведёт к ошибке.\n" +
        "Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||."
	},{
		h3:"Дата и Время",
		p:"new Date(year, month, date, hours, minutes, seconds, ms)\n" +
        "Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице\n" +
        "Получение компонентов даты\n" +
        "Для доступа к компонентам даты-времени объекта Date используются следующие методы:\n" +
        "getFullYear()\n" +
        "Получить год (из 4 цифр)\n" +
        "getMonth()\n" +
        "Получить месяц, от 0 до 11.\n" +
        "getDate()\n" +
        "Получить число месяца, от 1 до 31.\n" +
        "getHours(), getMinutes(), getSeconds(), getMilliseconds()\n" +
        "Получить соответствующие компоненты.\n" +
        "getDay()\n" +
        "Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).\n" +
        "Все методы, указанные выше, возвращают результат для местной временной зоны.\n" +
        "Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после get вставляется UTC.\n" +
        "Установка компонентов даты\n" +
        "Следующие методы позволяют устанавливать компоненты даты и времени:\n" +
        "setFullYear(year [, month, date])\n" +
        "setMonth(month [, date])\n" +
        "setDate(date)\n" +
        "setHours(hour [, min, sec, ms])\n" +
        "setMinutes(min [, sec, ms])\n" +
        "setSeconds(sec [, ms])\n" +
        "setMilliseconds(ms)\n" +
        "setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)\n" +
        "console.time(метка) – включить внутренний хронометр браузера с меткой.\n" +
        "console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.\n" +
        "Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date (кроме IE8-)\n" +
        "Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее."
	}]
}, {
    h2: "Замыкания",
    p:[{
        h3: "Глобальный объект",
        p: "Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные»\n" +
        "в глобальных обьектах Фигурные скобки, которые используются в for, while, if, в отличие от объявлений функции, имеют «декоративный» характер\n" +
        "В результате инициализации, к началу выполнения кода:\n" +
        "Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.\n" +
        "Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них."
    },{
        h3: "Замыкания, функции изнутри",
        p: "Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.\n" +
        "Мы будем называть этот объект «лексическое окружение» или просто «объект переменных».\n" +
        "При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.\n" +
        "В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.\n" +
        "Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window.\n" +
        "При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.\n" +
        "Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.\n" +
        "Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.\n" +
        "Тем не менее, в JavaScript есть небольшая терминологическая особенность.\n" +
        "Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.\n" +
        "Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных."
    },{
        h3: "[[Scope]] для new Function",
        p: "При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.\n" +
        "Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров."
    },{
        h3: "Локальные переменные для объекта",
        p: "getNext() – получить следующее значение, то, что раньше делал вызов counter().\n" +
        "set(value) – поставить значение.\n" +
        "reset() – обнулить счётчик\n" +
        "ПРИМЕР :counter.set(5);\n" +
        "alert( counter() ); // 5"
    },{
        h3: "Модули через замыкания",
        p: "на месте» разрешено вызывать только Function Expression.\n" +
        "Общее правило таково:\n" +
        "Если браузер видит function в основном потоке кода – он считает, что это Function Declaration.\n" +
        "Если же function идёт в составе более сложного выражения, то он считает, что это Function Expression.\n" +
        "Для этого нужно завернуть функцию в скобки и браузер поймет , что у нас Function Expression, который по правилам JavaScript можно вызвать «на месте»." +
        "Можно показать это другим способом, например поставив перед функцией оператор \"+\" или \"!\" перед функцией" +
        "Модуль при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.\n" +
        "Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание.\n" +
        "Например, defaults из примера выше имеет доступ к assignDefaults.\n" +
        "Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.\n" +
        "Можно придумать и много других вариаций такого подхода. В конце концов, «модуль» – это всего лишь функция-обёртка для скрытия переменных."
    },{
        h3: "Управление памятью в JavaScript",
        p: "Для очистки памяти от недостижимых значений в браузерах используется автоматический Сборщик мусора (англ. Garbage collection, GC), встроенный в интерпретатор, который наблюдает за объектами и время от времени удаляет недостижимые\n" +
        "Есть одно упрощение для работы с памятью: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка».\n" +
        "Верно – в том плане, что если ссылок на значение нет, то память из-под него очищается.\n" +
        "Неверно – в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти.\n" +
        "Такая ситуация возникает с объектами, которые ссылаются друг на друга:\n" +
        "var vasya = {};\n" +
        "var petya = {};\n" +
        "vasya.friend = petya;\n" +
        "petya.friend = vasya;\n" +
        "vasya = petya = null;"
    },{
        h3: "Устаревшая конструкция \"with\"",
        p: "Свойства из разных объектов используются как обычные переменные… Магия! Порядок поиска переменных в выделенном коде: size => obj => window.\n" +
        "При использовании with, как и во вложенных функциях – переменная изменяется в той области, где была найдена.\n" +
        "Вместо with рекомендуется использовать временную переменную\n" +
        "Конструкция with(obj) { ... } использует obj как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в obj.\n" +
        "Конструкция with устарела и не рекомендуется по ряду причин. Избегайте её."
    }]
}, {
    h2: "Методы объектов и контекст вызова",
    p: [{
        h3:"Методы объектов, this",
        p: "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.\n" +
        "Через this метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком\n" +
        "Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.\n" +
        "Значение this называется контекстом вызова и будет определено в момент вызова функции.\n" +
        "Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this\n" +
        "Если функция использует this – это подразумевает работу с объектом. Но и прямой вызов func() технически возможен.\n" +
        "Как правило, такая ситуация возникает при ошибке в разработке.\n" +
        "При этом this получает значение window, глобального объекта\n" +
        "А в режиме use strict вместо глобального объекта this будет undefined\n" +
        "Контекст this никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).\n" +
        "Любой более хитрый вызов приведёт к потере контекста"
    },{
        h3:"Преобразование объектов: toString и valueOf",
        p:"Строковое преобразование – если объект выводится через alert(obj).\n" +
        "Результатом toString может быть любой примитив\n" +
        "Метод toString не обязан возвращать именно строку.\n" +
        "Его результат может быть любого примитивного типа. Например, это может быть число если обьект преобразования имеет числовые индексы\n" +
        "Численное преобразование – при арифметических операциях, сравнении с примитивом.\n" +
        "Для численного преобразования объекта используется метод valueOf, а если его нет – то toString\n" +
        "Логическое преобразование – при if(obj) и других логических операциях. И приравнивается к true\n" +
        "Проще всего – с логическим преобразованием.\n" +
        "Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}\n" +
        "Две стадии преобразования\n" +
        "Объект Date, по историческим причинам, является исключением.\n" +
        "Бинарный оператор плюс + обычно использует числовое преобразование и метод valueOf. Как мы уже знаем, если подходящего valueOf нет (а его нет у большинства объектов), то используется toString, так что в итоге преобразование происходит к строке. Но если есть valueOf, то используется valueOf.\n" +
        "У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.\n" +
        "…Но оператор + для Date использует именно toString (хотя должен бы valueOf).\n" +
        "Это и есть исключение\n" +
        "В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val."
    },{
        h3:"Создание объектов через \"new\"",
        p:"Обычный синтаксис {...} позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.\n" +
        "Для этого используют «функции-конструкторы», запуская их при помощи специального оператора new.\n" +
        "Заметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи new. Как-то особым образом указывать, что она – конструктор – не надо.\n" +
        "Но, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal.\n" +
        "Детальнее – функция, запущенная через new, делает следующее:\n" +
        "Создаётся новый пустой объект.\n" +
        "Ключевое слово this получает ссылку на этот объект.\n" +
        "Функция выполняется. Как правило, она модифицирует this (т.е. этот новый объект), добавляет методы, свойства.\n" +
        "Возвращается this.\n" +
        "Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.\n" +
        "Но если явный вызов return всё же есть, то применяется простое правило:\n" +
        "При вызове return с объектом, будет возвращён он, а не this.\n" +
        "При вызове return с примитивным значением, оно будет отброшено.\n" +
        "Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this\n" +
        "Кстати, при вызове new без аргументов скобки можно не ставить(НО ЭТО БУДЕТ ЯВЛЯТЬСЯ ПЛОХИМ СТИЛЕМ НАПИСАНИЯ КОДА)"
    },{
        h3:"Дескрипторы, геттеры и сеттеры свойств",
        p:"Основной метод для управления свойствами – Object.defineProperty.\n" +
        "Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.\n" +
        "Синтаксис:\n" +
        "Object.defineProperty(obj, prop, descriptor)\n" +
        "Аргументы:\n" +
        "obj\n" +
        "Объект, в котором объявляется свойство.\n" +
        "prop\n" +
        "Имя свойства, которое нужно объявить или модифицировать.\n" +
        "descriptor\n" +
        "Дескриптор – объект, который описывает поведение свойства.\n" +
        "В нём могут быть следующие поля:\n" +
        "value – значение свойства, по умолчанию undefined\n" +
        "writable – значение свойства можно менять, если true. По умолчанию false.\n" +
        "configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.\n" +
        "enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.\n" +
        "get – функция, которая возвращает значение свойства. По умолчанию undefined.\n" +
        "set – функция, которая записывает значение свойства. По умолчанию undefined.\n" +
        "Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.\n" +
        "Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:\n" +
        "Заметим, что без use strict операция записи «молча» не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.\n" +
        "Свойство, скрытое для for…in\n" +
        "Встроенный метод toString, как и большинство встроенных методов, не участвует в цикле for..in. Это удобно, так как обычно такое свойство является «служебным».\n" +
        "К сожалению, свойство toString, объявленное обычным способом, будет видно в цикле for..in\n" +
        "Object.keys(obj), Object.getOwnPropertyNames(obj)\n" +
        "Возвращают массив – список свойств объекта.\n" +
        "Object.keys возвращает только enumerable-свойства.\n" +
        "Object.getOwnPropertyNames – возвращает все:\n" +
        "Object.getOwnPropertyDescriptor(obj, prop)\n" +
        "Возвращает дескриптор для свойства obj[prop].\n" +
        "Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений\n" +
        "…И несколько методов, которые используются очень редко:\n" +
        "Object.preventExtensions(obj)\n" +
        "Запрещает добавление свойств в объект.\n" +
        "Object.seal(obj)\n" +
        "Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.\n" +
        "Object.freeze(obj)\n" +
        "Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.\n" +
        "Object.isExtensible(obj)\n" +
        "Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.\n" +
        "Object.isSealed(obj)\n" +
        "Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.\n" +
        "Object.isFrozen(obj)\n" +
        "Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.\n"
    },{
        h3:"Статические и фабричные методы",
        p:"Преимущества использования фабричных методов:\n" +
        "\n" +
        "Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.\n" +
        "Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.\n" +
        "Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.\n" +
        "Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.\n" +
        "А в остальных случаях отличная альтернатива – фабричные методы.\n" +
        "Статические свойства и методы объекта удобно применять в следующих случаях:\n" +
        "Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.\n" +
        "Методы, не привязанные к конкретному объекту, например сравнение.\n" +
        "Вспомогательные методы, которые полезны вне объекта, например для форматирования даты."
    },{
        h3:"Явное указание this: \"call\", \"apply\"",
        p:"При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.\n" +
        "Это называется «одалживание метода» (на англ. method borrowing).\n" +
        "Используем эту технику для упрощения манипуляций с arguments.\n" +
        "Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет.\n" +
        "Метод apply\n" +
        "Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply.\n" +
        "Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка\n" +
        "Значение this устанавливается в зависимости от того, как вызвана функция:\n" +
        "При вызове функции как метода:\n" +
        "obj.func(...)    // this = obj\n" +
        "obj[\"func\"](...)\n" +
        "При обычном вызове:\n" +
        "func(...) // this = window (ES3) /undefined (ES5)\n" +
        "В new:\n" +
        "new func() // this = {} (новый объект)\n" +
        "Явное указание:\n" +
        "func.apply(context, args) // this = context (явная передача)\n" +
        "func.call(context, arg1, arg2, ...)"
    },{
        h3:"Привязка контекста и карринг: \"bind\"",
        p:"Функция сама по себе не запоминает контекст выполнения.\n" +
        "Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию:\n" +
        "setTimeout(function() {\n" +
        "  obj.func();\n" +
        "})\n" +
        "…Либо использовать bind:\n" +
        "setTimeout(obj.func.bind(obj));\n" +
        "Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.\n" +
        "Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз."
    },{
        h3:"Функции-обёртки, декораторы",
        p:"Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.\n" +
        "Декораторы можно не только повторно использовать, но и комбинировать!\n" +
        "Это кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода «фичи» или возможности, которые можно «нацепить» на любую функцию. Можно один, а можно несколько.\n" +
        "Скажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.\n" +
        "Предлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними."
    }]
}, {
    h2: "Некторорые другие возможности",
    p: [{
        h3:"Типы данных: [[Class]], instanceof и утки",
        p:" Секретное свойство [[Class]]\n" +
        "Для встроенных объектов есть одна «секретная» возможность узнать их тип, которая связана с методом toString.\n" +
        "Во всех встроенных объектах есть специальное свойство [[Class]], в котором хранится информация о его типе или конструкторе.\n" +
        "Оно взято в квадратные скобки, так как это свойство – внутреннее. Явно получить его нельзя, но можно прочитать его «в обход», воспользовавшись методом toString стандартного объекта Object.\n" +
        "Его внутренняя реализация выводит [[Class]] в небольшом обрамлении, как \"[object значение]\".\n" +
        "Оператор instanceof позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.\n" +
        "Для написания полиморфных (это удобно!) функций нам нужна проверка типов.\n" +
        "Для примитивов с ней отлично справляется оператор typeof.\n" +
        "У него две особенности:\n" +
        "Он считает null объектом, это внутренняя ошибка в языке.\n" +
        "Для функций он возвращает function, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.\n" +
        "Для встроенных объектов мы можем получить тип из скрытого свойства [[Class]], при помощи вызова {}.toString.call(obj).slice(8, -1). Для конструкторов, которые объявлены нами, [[Class]] всегда равно \"Object\".\n" +
        "Оператор obj instanceof Func проверяет, создан ли объект obj функцией Func, работает для любых конструкторов. Более подробно мы разберём его в главе Проверка класса: \"instanceof\".\n" +
        "И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется «утиная типизация»."
    },{
        h3:"Формат JSON, метод toJSON",
        p:" Данные в формате JSON (RFC 4627) представляют собой:\n" +
        "JavaScript-объекты { ... } или\n" +
        "Массивы [ ... ] или\n" +
        "Значения одного из типов:\n" +
        "строки в двойных кавычках,\n" +
        "число,\n" +
        "логическое значение true/false,\n" +
        "null.\n" +
        " Основные методы для работы с JSON в JavaScript – это:\n" +
        "JSON.parse – читает объекты из строки в формате JSON.\n" +
        "JSON.stringify – превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.\n" +
        " Вызов JSON.parse(str) превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.\n" +
        "Объекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках.\n" +
        "Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.\n" +
        "Есть нестандартное расширение формата JSON, которое называется JSON5 и как раз разрешает ключи без кавычек, комментарии и т.п, как в обычном JavaScript. На данном этапе это отдельная библиотека.\n" +
        " Метод JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.\n" +
        "При сериализации объекта вызывается его метод toJSON.\n" +
        "Если такого метода нет – перечисляются его свойства, кроме функций.\n" +
        "Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод toJSON. Его результат в данном случае – строка в таймзоне UTC.\n"
    },{
        h3:"setTimeout и setInterval",
        p:" Методы setInterval(func, delay) и setTimeout(func, delay) позволяют запускать func регулярно/один раз через delay миллисекунд.\n" +
        "Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом clearInterval/clearTimeout.\n" +
        "В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо setInterval используют рекурсивный setTimeout.\n" +
        "Минимальная задержка по стандарту составляет 4 мс. Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки.\n" +
        "В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.\n" +
        "Браузерных особенностей почти нет, разве что вызов setInterval(..., 0) с нулевой задержкой в IE недопустим, нужно указывать setInterval(..., 1)."
    },{
        h3:"Запуск кода из строки: eval",
        p:" Функция eval(code) позволяет выполнить код, переданный ей в виде строки.\n" +
        "Этот код будет выполнен в текущей области видимости.\n" +
        "При вызове eval имеет полный доступ к локальным переменным.\n" +
        "Это означает, что текущие переменные могут быть изменены или дополнены\n" +
        " В строгом режиме eval имеет свою область видимости\n" +
        "В строгом режиме функционал eval чуть-чуть меняется.\n" +
        "При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу\n" +
        "Неграмотное использование eval\n" +
        "Начнём с того, что eval применяется очень редко. Действительно редко. Есть даже такое выражение «eval is evil» (eval – зло).\n" +
        "Причина проста: когда-то JavaScript был гораздо более слабым языком, чем сейчас, и некоторые вещи без eval было сделать невозможно. Но те времена давно прошли. И теперь найти тот случай, когда действительно надо выполнить код из строки – это надо постараться.\n" +
        "Но если вы действительно знаете, что это именно тот случай и вам необходим eval – есть ряд вещей, которые нужно иметь в виду.\n" +
        "Доступ к локальным переменным – худшее, что можно сделать при eval.\n" +
        "Дело в том, что локальные переменные могут быть легко переименованы\n" +
        "JSON и eval\n" +
        "В браузерах IE7- не было методов JSON.stringify и JSON.parse, поэтому работа с JSON происходила через eval.\n" +
        "Этот способ работы с JSON давно устарел, но его можно встретить кое-где в старом коде, так что для примера рассмотрим его.\n" +
        "Вызов eval(code) выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.\n" +
        "Осторожно, злой JSON!\n" +
        "Если мы получаем JSON из недоверенного источника, например с чужого сервера, то разбор через eval может быть опасен.\n" +
        "Например, чужой сервер может быть взломан (за свой-то код мы отвечаем, а за чужой – нет), и вместо JSON вставлен злонамеренный JavaScript-код.\n" +
        "Поэтому рекомендуется, всё же, использовать JSON.parse.\n" +
        "При разборе через JSON.parse некорректный JSON просто приведёт к ошибке, а вот при разборе через eval этот код реально выполнится, он может вывести что-то на странице, перенаправить посетителя куда-то и т.п.\n"
    },{
        h3:"Перехват ошибок, \"try..catch\"",
        p:" Обработка ошибок – большая и важная тема.\n" +
        "В JavaScript для этого предусмотрены:\n" +
        "Конструкция try..catch..finally – она позволяет обработать произвольные ошибки в блоке кода.\n" +
        "Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего.\n" +
        "Кроме того, иногда проверить просто невозможно, например JSON.parse(str) не позволяет «проверить» формат строки перед разбором. В этом случае блок try..catch необходим.\n" +
        "Полный вид конструкции:\n" +
        "          try {\n" +
        "   .. пробуем выполнить код ..\n" +
        "} catch(e) {\n" +
        "   .. перехватываем исключение ..\n" +
        "} finally {\n" +
        "   .. выполняем всегда ..\n" +
        "}\n" +
        "Возможны также варианты try..catch или try..finally.\n" +
        "Оператор throw err генерирует свою ошибку, в качестве err рекомендуется использовать объекты, совместимые с встроенным типом Error, содержащие свойства message и name.\n" +
        "Кроме того, мы рассмотрели некоторые важные приёмы:\n" +
        "Проброс исключения – catch(err) должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные – пробрасывать дальше через throw err.\n" +
        "Определить, нужная ли это ошибка, можно, например, по свойству name.\n" +
        "Оборачивание исключений – функция, в процессе работы которой возможны различные виды ошибок, может «обернуть их» в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы, при необходимости, можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования.\n" +
        "В window.onerror можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис."
    }]
}, {
    h2: "ООП в функциональном стиле",
    p: [{
        h3:"Введение",
        p:"ООП – это не просто объекты\n" +
        "В JavaScript объекты часто используются просто как коллекции.\n" +
        "Например, встроенный объект Math содержит функции (Math.sin, Math.pow, …) и данные (константа Math.PI).\n" +
        "При таком использовании объектов мы не можем сказать, что «применён объектно-ориентированный подход». В частности, никакую «единую сущность» Math из себя не представляет, это просто коллекция независимых функций с общим префиксом Math.\n" +
        "Класс в ООП\n" +
        "Классом в объектно-ориентированной разработке называют шаблон/программный код, предназначенный для создания объектов и методов.\n" +
        "В JavaScript классы можно организовать по-разному. Говорят, что класс User написан в «функциональном» стиле. Далее мы также увидим «прототипный» стиль"
    },{
        h3:"Внутренний и внешний интерфейс",
        p:" Внутренний и внешний интерфейс\n" +
        "В программировании мы будем разделять методы и свойства объекта на две группы:\n" +
        "Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).\n" +
        "Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными».\n" +
        "Шаг 1: публичное и приватное свойство\n" +
        "Шаг 2: публичный и приватный методы\n" +
        "Шаг 3: константа\n" +
        "Шаг 4: доступ к объекту из внутреннего метода"
    },{
        h3:"Геттеры и сеттеры",
        p:" Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют «сеттер» (setter method).\n" +
		"Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию – «геттер» (getter method).\n" +
		"Для большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает и за запись, и за чтение.При вызове без параметров такой метод возвращает свойство, а при передаче параметра – назначает его."
    },{
        h3:"Функциональное наследование",
        p:" Организация наследования, которая описана в этой главе, называется «функциональным паттерном наследования».\n" +
        "Её общая схема (кратко):\n" +
        "Объявляется конструктор родителя Machine. В нём могут быть приватные (private), публичные (public) и защищённые (protected) свойства\n" +
        "Для наследования конструктор потомка вызывает родителя в своём контексте через apply. После чего может добавить свои переменные и методы \n" +
        "свойства, полученные от родителя, можно перезаписать своими. Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную\n" +
        "Строку можно упростить до parentProtected(args), если метод родителя не использует this, а, например, привязан к var self = this\n" +
        "Надо сказать, что способ наследования, описанный в этой главе, используется нечасто.\n" +
        "В следующих главах мы будем изучать прототипный подход, который обладает рядом преимуществ.\n" +
        "Но знать и понимать его необходимо, поскольку во многих существующих библиотеках классы написаны в функциональном стиле, и расширять/наследовать от них можно только так"
    }]
}, {
    h2: "ООП в прототипном стиле",
    p:[{
        h3:"Прототип объекта",
        p:"Методы для работы с proto\n" +
        "В современных браузерах есть два дополнительных метода для работы с __proto__. Зачем они нужны, если есть __proto__? В общем-то, не очень нужны, но по историческим причинам тоже существуют.\n" +
        "Чтение: Object.getPrototypeOf(obj)\n" +
        "Возвращает obj.__proto__ (кроме IE8-)\n" +
        "Запись: Object.setPrototypeOf(obj, proto)\n" +
        "Устанавливает obj.__proto__ = proto (кроме IE10-).\n" +
        "Кроме того, есть ещё один вспомогательный метод:\n" +
        "Создание объекта с прототипом: Object.create(proto, descriptors)\n" +
        "Создаёт пустой объект с __proto__, равным первому аргументу (кроме IE8-), второй необязательный аргумент может содержать дескрипторы свойств.\n" +
        "В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства __proto__.\n" +
        "При установке свойства rabbit.__proto__ = animal говорят, что объект animal будет «прототипом» rabbit.\n" +
        "При чтении свойства из объекта, если его в нём нет, оно ищется в __proto__. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj.\n" +
        "Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку, когда один объект ссылается на другой при помощи __proto__, тот ссылается на третий, и так далее.\n" +
        "В современных браузерах есть методы для работы с прототипом:\n" +
        "Object.getPrototypeOf(obj) (кроме IE8-)\n" +
        "Object.setPrototypeOf(obj, proto) (кроме IE10-)\n" +
        "Object.create(proto, descriptors) (кроме IE8-)\n" +
        "Возможно, вас смущает недостаточная поддержка __proto__ в старых IE. Но это не страшно. В последующих главах мы рассмотрим дополнительные методы работы с __proto__, включая те, которые работают везде.\n" +
        "Также мы рассмотрим, как свойство __proto__ используется внутри самого языка JavaScript и как организовать классы с его помощью."
    },{
        h3:"Свойство F.prototype и создание объектов через new",
        p:"Самым очевидным решением является назначение __proto__ в конструкторе.\n" +
        "Недостаток этого подхода – он не работает в IE10-.\n" +
        "К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.\n" +
        "Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.\n" +
        "При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.\n" +
        "Свойство prototype имеет смысл только у конструктора\n" +
        "Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.\n" +
        "Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать __proto__ для новых объектов.\n" +
        "Значением prototype может быть только объект\n" +
        "Технически, в это свойство можно записать что угодно.\n" +
        "Однако, при работе new, свойство prototype будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано. \n" +
        "Свойство constructor\n" +
        "У каждой функции по умолчанию уже есть свойство prototype.\n" +
        "Оно содержит объект такого вида:\n" +
        "function Rabbit() {}\n" +
        "Rabbit.prototype = {\n" +
        "  constructor: Rabbit\n" +
        "};\n" +
        "В коде выше я создал Rabbit.prototype вручную, но ровно такой же – генерируется автоматически\n" +
        "Свойство constructor легко потерять\n" +
        "JavaScript никак не использует свойство constructor. То есть, оно создаётся автоматически, а что с ним происходит дальше – это уже наша забота. В стандарте прописано только его создание.\n" +
        "В частности, при перезаписи Rabbit.prototype = { jumps: true } свойства constructor больше не будет.\n" +
        "Сам интерпретатор JavaScript его в служебных целях не требует, поэтому в работе объектов ничего не «сломается». Но если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие constructor вручную:\n" +
        "Rabbit.prototype = {\n" +
        "  jumps: true,\n" +
        "  constructor: Rabbit\n" +
        "};\n" +
        "Либо можно поступить аккуратно и добавить свойства к встроенному prototype без его замены:\n" +
        "// сохранится встроенный constructor\n" +
        "Rabbit.prototype.jumps = true\n" +
        "Эмуляция Object.create для IE8-\n" +
        "Как мы только что видели, с конструкторами всё просто, назначить прототип можно кросс-браузерно при помощи F.prototype.\n" +
        "Теперь небольшое «лирическое отступление» в область совместимости.\n" +
        "Прямые методы работы с прототипом отсутствуют в старых IE, но один из них – Object.create(proto) можно эмулировать, как раз при помощи prototype. И он будет работать везде, даже в самых устаревших браузерах\n" +
        "Для произвольной функции – назовём её Person, верно следующее:\n" +
        "Прототип __proto__ новых объектов, создаваемых через new Person, можно задавать при помощи свойства Person.prototype.\n" +
        "Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person. Его можно использовать, чтобы из самого объекта получить функцию, которая его создала. Однако, JavaScript никак не поддерживает корректность этого свойства, поэтому программист может его изменить или удалить.\n" +
        "Современный метод Object.create(proto) можно эмулировать при помощи prototype, если хочется, чтобы он работал в IE8-."
    },{
        h3:"Встроенные \"классы\" в JavaScript",
        p:"Методы встроенных объектов хранятся в их прототипах.\n" +
        "Встроенные прототипы можно расширить или поменять.\n" +
        "Добавление методов в Object.prototype, если оно не сопровождается Object.defineProperty с установкой enumerable (IE9+), «сломает» циклы for..in, поэтому стараются в этот прототип методы не добавлять.\n" +
        "Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.\n" +
        "Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как Object.create, Object.keys, Function.prototype.bind и т.п. Это допустимо и как раз делается es5-shim."
    },{
        h3:"Свои классы на прототипах",
        p:"Класс через прототип\n" +
        "А теперь создадим аналогичный класс, используя прототипы, наподобие того, как сделаны классы Object, Date и остальные.\n" +
        "Чтобы объявить свой класс, нужно:\n" +
        "Объявить функцию-конструктор.\n" +
        "Записать методы и свойства, нужные всем объектам класса, в prototype.\n" +
        "Достоинства\n" +
        "Функциональный стиль записывает в каждый объект и свойства и методы, а прототипный – только свойства. Поэтому прототипный стиль – быстрее и экономнее по памяти.\n" +
        "Недостатки\n" +
        "При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором."
    },{
        h3:"Наследование классов в JavaScript",
        p:"Наследование на уровне объектов в JavaScript, как мы видели, реализуется через ссылку __proto__.\n" +
        "Теперь поговорим о наследовании на уровне классов, то есть когда объекты, создаваемые, к примеру, через new Admin, должны иметь все методы, которые есть у объектов, создаваемых через new User, и ещё какие-то свои.\n" +
        "Наследование Array от Object\n" +
        "Методы массивов Array хранятся в Array.prototype.\n" +
        "Array.prototype имеет прототипом Object.prototype.\n" +
        "Поэтому когда экземпляры класса Array хотят получить метод массива – они берут его из своего прототипа, например Array.prototype.slice.\n" +
        "Если же нужен метод объекта, например, hasOwnProperty, то его в Array.prototype нет, и он берётся из Object.prototype.\n" +
        "Для доступа к свойствам используют console.dir \n" +
        "Для наследования нужно, чтобы «склад методов потомка» (Child.prototype) наследовал от «склада метода родителей» (Parent.prototype).\n" +
        "Это можно сделать при помощи Object.create"
    },{
        h3:"Проверка класса: \"instanceof\"",
        p:"Оператор instanceof позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования\n" +
        "Алгоритм работы instanceof состоит в том, что \n" +
        "Вызов obj instanceof Constructor возвращает true, если объект принадлежит классу Constructor или классу, наследующему от него\n" +
        "Алгоритм проверки obj instanceof Constructor:\n" +
        "Получить obj.__proto__\n" +
        "Сравнить obj.__proto__ с Constructor.prototype\n" +
        "Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false).\n" +
        "Вообще, у каждого окна и фрейма – своя иерархия объектов и свой window .\n" +
        "Как правило, эта проблема возникает со встроенными объектами, в этом случае используется проверка внутреннего свойства [[Class]], которое подробнее описано в главе Типы данных: [[Class]], instanceof и утки."
    },{
        h3:"Свои ошибки, наследование от Error",
        p:"Чтобы наследовать от ошибок Error, нужно самостоятельно позаботиться о name, message и stack.\n" +
        "Благодаря тому, что instanceof поддерживает наследование, удобно организуются проверки на нужный тип. В иерархию ошибок можно в любой момент добавить новые классы, с понятным кодом и предсказуемым поведением.\n" +
        "Чтобы создавать наследники от Error было проще, можно создать класс CustomError, записать в него универсальный код, наподобие PropertyError и далее наследовать уже от него"
    },{
        h3:"Примеси",
        p:"В JavaScript невозможно унаследовать от двух и более объектов. Ссылка __proto__ – только одна.\n" +
        "Но потребность такая существует – к примеру, мы написали код, реализующий методы работы с шаблонизатором или методы по обмену событиями, и хочется легко и непринуждённо добавлять эти возможности к любому классу.\n" +
        "Обычно это делают через примеси.\n" +
        "Примесь (англ. mixin) – класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.\n" +
        "Для добавления примеси в класс – её просто «подмешивают» в прототип.\n" +
        "«Подмешать» можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты. Их уже разрешать – разработчику. Например, можно заменить конфликтующий метод на свой, который будет решать несколько задач сразу. Конфликты при грамотно оформленных примесях возникают редко"
    }]
}, {
    h2: "Современные возможности ES-2015",
    p: [{
        h3:"ES-2015 сейчас",
        p:"Стандарт ES-2015 был принят в июне 2015. Пока что большинство браузеров реализуют его частично, текущее состояние реализации различных возможностей можно посмотреть здесь: https://kangax.github.io/compat-table/es6/.\n" +
        "Когда стандарт будет более-менее поддерживаться во всех браузерах, то весь учебник будет обновлён в соответствии с ним. Пока же, как центральное место для «сбора» современных фич JavaScript, создан этот раздел.\n" +
        "Чтобы писать код на ES-2015 прямо сейчас, есть следующие варианты.\n" +
        "Конкретный движок JS\n" +
        "Самое простое – это когда нужен один конкретный движок JS, например V8 (Chrome).\n" +
        "Тогда можно использовать только то, что поддерживается именно в нём. Заметим, что в V8 большинство возможностей ES-2015 поддерживаются только при включённом use strict.\n" +
        "При разработке на Node.JS обычно так и делают. Если же нужна кросс-браузерная поддержка, то этот вариант не подойдёт.\n" +
        "Babel.JS\n" +
        "Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.\n" +
        "Он состоит из двух частей:\n" +
        "Собственно транспайлер, который переписывает код.\n" +
        "Полифилл, который добавляет методы Array.from, String.prototype.repeat и другие.\n" +
        "На странице https://babeljs.io/repl/ можно поэкспериментировать с транспайлером: слева вводится код в ES-2015, а справа появляется результат его преобразования в ES5.\n" +
        "Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.\n" +
        "Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них"
    },{
        h3:"Переменные: let и const",
        p:"В ES-2015 предусмотрены новые способы объявления переменных: через let и const вместо var.\n" +
        "У объявлений переменной через let есть три основных отличия от var:\n" +
        "\n" +
        "1.Область видимости переменной let – блок {...}.\n" +
        "\n" +
        "Как мы помним, переменная, объявленная через var, видна везде в функции.\n" +
        "\n" +
        "Переменная, объявленная через let, видна только в рамках блока {...}, в котором объявлена.\n" +
        "\n" +
        "Это, в частности, влияет на объявления внутри if, while или for.\n" +
        "Объявление const задаёт константу, то есть переменную, которую нельзя менять\n" +
        "Заметим, что если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё"
    },{
        h3:"Деструктуризация",
        p:"Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части\n" +
        "Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора \"...\" («spread», троеточие\n" +
        "Если значений в массиве меньше, чем переменных – ошибки не будет, просто присвоится undefined"
    },{
        h3:"Функции",
        p:"введена дополнительная короткая запись через стрелочку =>\n" +
        "Слева от => находится аргумент, а справа – выражение, которое нужно вернуть.\n" +
        "Если аргументов несколько, то нужно обернуть их в скобки\n" +
        "Когда тело функции достаточно большое, то можно его обернуть в фигурные скобки {…}\n" +
        "Заметим, что как только тело функции оборачивается в {…}, то её результат уже не возвращается автоматически. Такая функция должна делать явный return.\n" +
        "Внутри функций-стрелок – тот же this, что и снаружи\n" +
        "Функции стрелки нельзя запускать с new\n" +
        "Отсутствие у функции-стрелки \"своего this\" влечёт за собой естественное ограничение: такие функции нельзя использовать в качестве конструктора, то есть нельзя вызывать через new.\n" +
        "=> это не то же самое, что .bind(this)\n" +
        "Есть тонкое различие между функцией стрелкой => и обычной функцией, у которой вызван .bind(this):\n" +
        "Вызовом .bind(this) мы передаём текущий this, привязывая его к функции.\n" +
        "При => привязки не происходит, так как функция стрелка вообще не имеет контекста this и arguments. Поиск this и arguments в ней осуществляется так же, как и поиск обычной переменной, то есть, выше в замыкании. До появления стандарта ES-2015 такое было невозможно.\n" +
        ""
    },{
        h3:"Строки",
        p:"Добавлены ряд полезных методов общего назначения:\n" +
        "str.includes(s) – проверяет, включает ли одна строка в себя другую, возвращает true/false.\n" +
        "str.endsWith(s) – возвращает true, если строка str заканчивается подстрокой s.\n" +
        "str.startsWith(s) – возвращает true, если строка str начинается со строки s.\n" +
        "str.repeat(times) – повторяет строку str times раз.\n" +
        "Конечно, всё это можно было сделать при помощи других встроенных методов, но новые методы более удобны."
    },{
        h3:"Объекты и прототипы",
        p:"В ES-2015 появилось новое ключевое слово super. Оно предназначено только для использования в методах объекта.\n" +
        "Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа.\n" +
        "Улучшения в описании свойств:\n" +
        "Запись name: name можно заменить на просто name\n" +
        "Если имя свойства находится в переменной или задано выражением expr, то его можно указать в квадратных скобках [expr].\n" +
        "Свойства-функции можно оформить как методы: \"prop: function() {}\" → \"prop() {}\".\n" +
        "В методах работает обращение к свойствам прототипа через super.parentProperty.\n" +
        "Для работы с прототипом:\n" +
        "Object.setPrototypeOf(obj, proto) – метод для установки прототипа.\n" +
        "obj.__proto__ – ссылка на прототип.\n" +
        "Дополнительно:\n" +
        "Метод Object.assign(target, src1, src2...) – копирует свойства из всех аргументов в первый объект.\n" +
        "Метод Object.is(value1, value2) проверяет два значения на равенство. В отличие от === считает +0 и -0 разными числами. А также считает, что NaN равно самому себе"
    },{
        h3:"Классы",
        p:"Классы можно объявлять как в основном потоке кода, так и «инлайн», по аналогии с Function Declaration и Expression.\n" +
        "В объявлении классов можно использовать методы, геттеры/сеттеры и вычислимые названия методов.\n" +
        "При наследовании вызов конструктора родителя осуществляется через super(...args), вызов родительских методов – через super.method(...args).\n" +
        "Концепция классов, которая после долгих обсуждений получилась в стандарте ECMAScript, носит название «максимально минимальной». То есть, в неё вошли только те возможности, которые уж точно необходимы.\n" +
        "В частности, не вошли «приватные» и «защищённые» свойства. То есть, все свойства и методы класса технически доступны снаружи. Возможно, они появятся в будущих редакциях стандарта."
    },{
        h3:"Тип данных Symbol",
        p:"У символов есть и соответствующий typeof\n" +
        "Существует «глобальный реестр» символов, который позволяет, при необходимости, иметь общие «глобальные» символы, которые можно получить из реестра по имени.\n" +
        "Для чтения (или создания, при отсутствии) «глобального» символа служит вызов Symbol.for(имя).\n" +
        "У вызова Symbol.for, который возвращает символ по имени, есть обратный вызов – Symbol.keyFor(sym). Он позволяет получить по глобальному символу его имя:\n" +
        "Symbol.keyFor возвращает undefined, если символ не глобальный\n" +
        "Заметим, что Symbol.keyFor работает только для глобальных символов, для остальных будет возвращено undefined\n" +
        "Символы – новый примитивный тип, предназначенный для уникальных идентификаторов.\n" +
        "Все символы уникальны. Символы с одинаковым именем не равны друг другу.\n" +
        "Существует глобальный реестр символов, доступных через метод Symbol.for(name). Для глобального символа можно получить имя вызовом и Symbol.keyFor(sym).\n" +
        "Основная область использования символов – это системные свойства объектов, которые задают разные аспекты их поведения. Поддержка у них пока небольшая, но она растёт. Системные символы позволяют разработчикам стандарта добавлять новые «особые» свойства объектов, при этом не резервируя соответствующие строковые значения.\n" +
        "Системные символы доступны как свойства функции Symbol, например Symbol.iterator.\n" +
        "Мы можем создавать и свои символы, использовать их в объектах. Записывать их как свойства Symbol, разумеется, нельзя. Если нужен глобально доступный символ, то используется Symbol.for(имя)."
    },{
        h3:"Итераторы",
        p:"Итератор – объект, предназначенный для перебора другого объекта.\n" +
        "У итератора должен быть метод next(), возвращающий объект {done: Boolean, value: any}, где value – очередное значение, а done: true в конце.\n" +
        "Метод Symbol.iterator предназначен для получения итератора из объекта. Цикл for..of делает это автоматически, но можно и вызвать его напрямую.\n" +
        "В современном стандарте есть много мест, где вместо массива используются более абстрактные «итерируемые» (со свойством Symbol.iterator) объекты, например оператор spread ....\n" +
        "Встроенные объекты, такие как массивы и строки, являются итерируемыми, в соответствии с описанным выше."
    },{
        h3:"Set, Map, WeakSet и WeakMap",
        p:"Map – коллекция для хранения записей вида ключ:значение.\n" +
        "Свойство map.size хранит общее количество записей в map\n" +
        "Как map сравнивает ключи\n" +
        "Для проверки значений на эквивалентность используется алгоритм SameValueZero. Он аналогичен строгому равенству ===, отличие – в том, что NaN считается равным NaN. Поэтому значение NaN также может быть использовано в качестве ключа.\n" +
        "Этот алгоритм нельзя изменять или задавать свою функцию сравнения.\n" +
        "map.delete(key) удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.\n" +
        "map.clear() – удаляет все записи, очищает map.\n" +
        "Для проверки существования ключа:\n" +
        "map.has(key) – возвращает true, если ключ есть, иначе false.\n" +
        "Для итерации по map используется один из трёх методов:\n" +
        "map.keys() – возвращает итерируемый объект для ключей,\n" +
        "map.values() – возвращает итерируемый объект для значений,\n" +
        "map.entries() – возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of\n" +
        "Перебор идёт в том же порядке, что и вставка\n" +
        "Перебор осуществляется в порядке вставки. Объекты Map гарантируют это, в отличие от обычных объектов Object.Кроме того у Map усть стандартный метод forEach фнфлогичный массиву\n" +
        "Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.\n" +
        "Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз.\n" +
        "set не создают лишних копий.\n" +
        "Альтернатива Set – это массивы с поиском дубликата при каждом добавлении, но они гораздо хуже по производительности. Или можно использовать обычные объекты, где в качестве ключа выступает какой-нибудь уникальный идентификатор посетителя. Но это менее удобно, чем простой и наглядный Set.\n" +
        "Основные методы:\n" +
        "set.add(item) – добавляет в коллекцию item, возвращает set (чейнится).\n" +
        "set.delete(item) – удаляет item из коллекции, возвращает true, если он там был, иначе false.\n" +
        "set.has(item) – возвращает true, если item есть в коллекции, иначе false.\n" +
        "set.clear() – очищает set.\n" +
        "Перебор Set осуществляется через forEach или for..of аналогично Map\n" +
        "Заметим, что в Set у функции в .forEach три аргумента: значение, ещё раз значение, и затем сам перебираемый объект set. При этом значение повторяется в аргументах два раза.\n" +
        "Так сделано для совместимости с Map, где у .forEach-функции также три аргумента. Но в Set первые два всегда совпадают и содержат очередное значение множества.\n" +
        "WeakSet – особый вид Set не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map.\n" +
        "То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти.\n" +
        "Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект.\n" +
        "Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует.\n" +
        "Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент."
    },{
        h3:"Promise",
        p:"Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).\n" +
        "На promise можно навешивать коллбэки двух типов:\n" +
        "onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».\n" +
        "onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».\n" +
        "Способ использования, в общих чертах, такой:\n" +
        "Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.\n" +
        "Внешний код, получив promise, навешивает на него обработчики.\n" +
        "По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.\n" +
        ".catch\n" +
        "Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.\n" +
        "Только один аргумент\n" +
        "Функции resolve/reject принимают ровно один аргумент – результат/ошибку.\n" +
        "Именно он передаётся обработчикам в .then \n" +
        "Промис – это специальный объект, который хранит своё состояние, текущий результат (если есть) и коллбэки.\n" +
        "При создании new Promise((resolve, reject) => ...) автоматически запускается функция-аргумент, которая должна вызвать resolve(result) при успешном выполнении и reject(error) – при ошибке.\n" +
        "Аргумент resolve/reject (только первый, остальные игнорируются) передаётся обработчикам на этом промисе.\n" +
        "Обработчики назначаются вызовом .then/catch.\n" +
        "Для передачи результата от одного обработчика к другому используется чейнинг.\n" +
        "У промисов есть некоторые ограничения. В частности, стандарт не предусматривает какой-то метод для «отмены» промиса, хотя в ряде ситуаций (http-запросы) это было бы довольно удобно. Возможно, он появится в следующей версии стандарта JavaScript.\n" +
        "\n" +
        "В современной JavaScript-разработке сложные цепочки с промисами используются редко, так как они куда проще описываются при помощи генераторов с библиотекой co, которые рассмотрены в соответствующей главе. Можно сказать, что промисы лежат в основе более продвинутых способов асинхронной разработки."
    },{
        h3:"Генераторы",
        p:"Генераторы – новый вид функций в современном JavaScript. Они отличаются от обычных тем, что могут приостанавливать своё выполнение, возвращать промежуточный результат и далее возобновлять его позже, в произвольный момент времени.\n" +
        "Создание генератора\n" +
        "Для объявления генератора используется новая синтаксическая конструкция: function* (функция со звёздочкой).\n" +
        "Её называют «функция-генератор» (generator function).\n" +
        "Заметим, однако, существенную особенность такого перебора!\n" +
        "\n" +
        "При запуске примера выше будет выведено значение 1, затем 2. Значение 3 выведено не будет. Это потому что стандартный перебор итератора игнорирует value на последнем значении, при done: true. Так что результат return в цикле for..of не выводится.\n" +
        "\n" +
        "Соответственно, если мы хотим, чтобы все значения возвращались при переборе через for..of, то надо возвращать их через yield " +
        "А зачем вообще return при таком раскладе, если его результат игнорируется? Он тоже нужен, но в других ситуациях. Перебор через for..of – в некотором смысле «исключение». Как мы увидим дальше, в других контекстах return очень даже востребован " +
        "Композиция генераторов\n" +
        "\n" +
        "Один генератор может включать в себя другие. Это называется композицией.\n" +
        "Библиотека co, как и execute, получает генератор и выполняет его.\n" +
        "Обязательно нужен catch\n" +
        "Частая ошибка начинающих – вообще забывать про обработку результата co. Даже если результата нет, ошибки нужно обработать через catch, иначе они «подвиснут» в промисе. " +
        "Библиотека co умеет выполнять не только промисы. Есть несколько видов значений, которые можно yield, и их обработает co:\n" +
        "\n" +
        "Промис.\n" +
        "Объект-генератор.\n" +
        "Функция-генератор function*() – co её выполнит, затем выполнит полученный генератор.\n" +
        "Функция с единственным аргументом вида function(callback) – библиотека co её запустит со своей функцией-callback и будет ожидать, что при ошибке она вызовет callback(err), а при успешном выполнении – callback(null, result). То есть, в первом аргументе – будет ошибка (если есть), а втором – результат (если нет ошибки). После чего результат будет передан в генератор.\n" +
        "Массив или объект из вышеперечисленного. При этом все задачи будут выполнены параллельно, и результат, в той же структуре, будет выдан наружу.\n " +
        "Устаревший yield function(callback)\n" +
        "Отдельно заметим вариант с yield function(callback). Такие функции, с единственным-аргументом callback’ом, в англоязычной литературе называют «thunk».\n" +
        "\n" +
        "Функция обязана выполниться и вызвать (асинхронно) либо callback(err) с ошибкой, либо callback(null, result) с результатом.\n" +
        "\n" +
        "Использование таких функций в yield является устаревшим подходом, так как там, где можно использовать yield function(callback), можно использовать и промисы. При этом промисы мощнее. Но в старом коде его ещё можно встретить. " +
        "Библиотека co технически позволяет писать код так:\n" +
        "\n" +
        "let user = yield fetchUser(url);\n" +
        "// вместо\n" +
        "// let user = yield* fetchUser(url);\n" +
        "То есть, можно сделать yield генератора, co() его выполнит и передаст значение обратно. Как мы видели выше, библиотека co – довольно всеядна. Однако, рекомендуется использовать для вызова функций-генераторов именно yield*.\n" +
        "\n" +
        "Причин для этого несколько:\n" +
        "\n" +
        "Делегирование генераторов yield* – это встроенный механизм JavaScript. Вместо возвращения значения обратно в co, выполнения кода библиотеки… Мы просто используем возможности языка. Это правильнее.\n" +
        "Поскольку не происходит лишних вызовов, это быстрее по производительности.\n" +
        "И, наконец, пожалуй, самое приятное – делегирование генераторов сохраняет стек.\n " +
        "И НЕ ЗАБЫВАЕМ! При запуске вложенных генераторов используем yield*"
    },{
        h3:"Модули",
        p:"Концепция модулей как способа организации JavaScript-кода существовала давно.\n" +
        "\n" +
        "Когда приложение сложное и кода много – мы пытаемся разбить его на файлы. В каждом файле описываем какую-то часть, а в дальнейшем – собираем эти части воедино.\n" +
        "\n" +
        "Модули в стандарте ECMAScript предоставляют удобные средства для этого.\n" +
        "\n" +
        "Такие средства предлагались сообществом и ранее, например:\n" +
        "\n" +
        "AMD – одна из самых древних систем организации модулей, требует лишь наличия клиентской библиотеки, к примеру, require.js, но поддерживается и серверными средствами.\n" +
        "CommonJS – система модулей, встроенная в сервер Node.JS. Требует поддержки на клиентской и серверной стороне.\n" +
        "UMD – система модулей, которая предложена в качестве универсальной. UMD-модули будут работать и в системе AMD и в CommonJS.\n " +
        "Модулем считается файл с кодом.\n" +
        "В этом файле ключевым словом export помечаются переменные и функции, которые могут быть использованы снаружи.\n" +
        "Другие модули могут подключать их через вызов import.\n" +
        "export\n" +
        "Ключевое слово export можно ставить:\n" +
        "перед объявлением переменных, функций и классов.\n" +
        "отдельно, при этом в фигурных скобках указывается, что именно экспортируется.\n " +
        "При помощи ключевого слова as можно указать, что переменная one будет доступна снаружи (экспортирована) под именем once, а two – под именем twice:\n" +
        "\n" +
        "export {one as once, two as twice}; " +
        "!!!!!Для экспорта обязательно нужно имя " +
        "import\n" +
        "Другие модули могут подключать экспортированные значения при помощи ключевого слова import.\n" +
        "Синтаксис:\n" +
        "import {one, two} from \"./nums\";\n" +
        "Здесь:\n" +
        "\"./nums\" – модуль, как правило это путь к файлу модуля.\n" +
        "one, two – импортируемые переменные, которые должны быть обозначены в nums словом export.\n" +
        "В результате импорта появятся локальные переменные one, two, которые будут содержать значения соответствующих экспортов. " +
        "Импортировать можно и под другим именем, указав его в «as» " +
        "Импорт всех значений в виде объекта\n" +
        "Можно импортировать все значения сразу в виде объекта вызовом import * as obj " +
        "export default\n" +
        "Выше мы видели, что модуль может экспортировать выбранные переменные при помощи export.\n" +
        "Однако, как правило, код стараются организовать так, чтобы каждый модуль делал одну вещь. Иначе говоря, «один файл – одна сущность, которую он описывает». Например, файл user.js содержит class User, файл login.js – функцию login() для авторизации, и т.п.\n" +
        "При этом модули, разумеется, будут использовать друг друга. Например, login.js, скорее всего, будет импортировать класс User из модуля user.js.\n" +
        "Для такой ситуации, когда один модуль экспортирует одно значение, предусмотрено особое ключевое сочетание export default.\n" +
        "Если поставить после export слово default, то значение станет «экспортом по умолчанию».\n" +
        "Такое значение можно импортировать без фигурных скобок. " +
        "«Экспорт по умолчанию» – своего рода «синтаксический сахар». Можно было бы и без него, импортировать значение обычным образом через фигурные скобки {…} " +
        "Использование\n" +
        "Современный стандарт ECMAScript описывает, как импортировать и экспортировать значения из модулей, но он ничего не говорит о том, как эти модули искать, загружать и т.п.\n" +
        "Такие механизмы предлагались в процессе создания стандарта, но были убраны по причине недостаточной проработанности. Возможно, они появятся в будущем.\n" +
        "Сейчас используются системы сборки, как правило, в сочетании с Babel.JS.\n" +
        "Система сборки обрабатывает скрипты, находит в них import/export и заменяет их на свои внутренние JavaScript-вызовы. При этом, как правило, много файлов-модулей объединяются в один или несколько скриптов, смотря как указано в конфигурации сборки.\n" +
        "Ниже вы можете увидеть полный пример использования модулей с системой сборки webpack.\n" +
        "В нём есть:\n" +
        "nums.js – модуль, экспортирующий one и two, как описано выше.\n" +
        "main.js – модуль, который импортирует one, two из nums и выводит их сумму.\n" +
        "webpack.config.js – конфигурация для системы сборки.\n" +
        "bundle.js – файл, который создала система сборки из main.js и nums.js.\n" +
        "index.html – простой HTML-файл"
    },{
        h3:"Proxy",
        p:"Прокси (proxy) – особый объект, смысл которого – перехватывать обращения к другому объекту и, при необходимости, модифицировать их. " +
        "let proxy = new Proxy(target, handler)\n" +
        "Здесь:\n" +
        "\n" +
        "target – объект, обращения к которому надо перехватывать.\n" +
        "handler – объект с «ловушками»: функциями-перехватчиками для операций к target.\n" +
        "Почти любая операция может быть перехвачена и обработана прокси до или даже вместо доступа к объекту target, например: чтение и запись свойств, получение списка свойств, вызов функции (если target – функция) и т.п.\n" +
        "Различных типов ловушек довольно много.\n" +
        "Если ловушки нет – операция идёт над target\n" +
        "Если для операции нет ловушки, то она выполняется напрямую над target. " +
        "get/set\n" +
        "\n" +
        "Самыми частыми являются ловушки для чтения и записи в объект:\n" +
        "\n" +
        "get(target, property, receiver)\n" +
        "Срабатывает при чтении свойства из прокси. Аргументы:\n" +
        "target – целевой объект, тот же который был передан первым аргументом в new Proxy.\n" +
        "property – имя свойства.\n" +
        "receiver – объект, к которому было применено присваивание. Обычно сам прокси, либо прототипно наследующий от него. Этот аргумент используется редко.\n" +
        "set(target, property, value, receiver)\n" +
        "Срабатывает при записи свойства в прокси.\n" +
        "Аргументы:\n" +
        "target – целевой объект, тот же который был передан первым аргументом в new Proxy.\n" +
        "property – имя свойства.\n" +
        "value – значение свойства.\n" +
        "receiver – объект, к которому было применено присваивание, обычно сам прокси, либо прототипно наследующий от него.\n" +
        "Метод set должен вернуть true, если присвоение успешно обработано и false в случае ошибки (приведёт к генерации TypeError). " +
        "has\n" +
        "Ловушка has срабатывает в операторе in и некоторых других случаях, когда проверяется наличие свойства. " +
        "deleteProperty\n" +
        "Ловушка deleteProperty по синтаксису аналогична get/has.\n" +
        "Срабатывает при операции delete, должна вернуть true, если удаление было успешным. " +
        "enumerate\n" +
        "Ловушка enumerate перехватывает операции for..in и for..of по объекту. " +
        "Если же ловушка enumerate есть, то она будет вызвана с единственным аргументом target и сможет вернуть итератор для свойств. " +
        "Посмотрим внимательнее, что происходит внутри enumerate:\n" +
        "Сначала получаем список интересующих нас свойств в виде массива.\n" +
        "Метод должен возвратить итератор по массиву. Встроенный итератор для массива получаем через вызов props[Symbol.iterator]().  " +
        "apply\n" +
        "Прокси умеет работать не только с обычными объектами, но и с функциями.\n" +
        "Если аргумент target прокси – функция, то становится доступна ловушка apply для её вызова.\n" +
        "Метод apply(target, thisArgument, argumentsList) получает:\n" +
        "target – исходный объект.\n" +
        "thisArgument – контекст this вызова.\n" +
        "argumentsList – аргументы вызова в виде массива. " +
        "construct\n" +
        "\n" +
        "Ловушка construct(target, argumentsList) перехватывает вызовы при помощи new.\n" +
        "\n" +
        "Она получает исходный объект target и список аргументов argumentsList. " +
        "Полный список\n" +
        "\n" +
        "Полный список возможных функций-перехватчиков, которые может задавать handler:\n" +
        "\n" +
        "getPrototypeOf – перехватывает обращение к методу getPrototypeOf.\n" +
        "setPrototypeOf – перехватывает обращение к методу setPrototypeOf.\n" +
        "isExtensible – перехватывает обращение к методу isExtensible.\n" +
        "preventExtensions – перехватывает обращение к методу preventExtensions.\n" +
        "getOwnPropertyDescriptor – перехватывает обращение к методу getOwnPropertyDescriptor.\n" +
        "defineProperty – перехватывает обращение к методу defineProperty.\n" +
        "has – перехватывает проверку существования свойства, которая используется в операторе in и в некоторых других методах встроенных объектов.\n" +
        "get – перехватывает чтение свойства.\n" +
        "set – перехватывает запись свойства.\n" +
        "deleteProperty – перехватывает удаление свойства оператором delete.\n" +
        "enumerate – срабатывает при вызове for..in или for..of, возвращает итератор для свойств объекта.\n" +
        "ownKeys – перехватывает обращения к методу getOwnPropertyNames.\n" +
        "apply – перехватывает вызовы target().\n" +
        "construct – перехватывает вызовы new target().\n" +
        "Каждый перехватчик запускается с handler в качестве this. Это означает, что handler кроме ловушек может содержать и другие полезные свойства и методы.\n" +
        "\n" +
        "Каждый перехватчик получает в аргументах target и дополнительные параметры в зависимости от типа.\n" +
        "\n" +
        "Если перехватчик в handler не указан, то операция совершается, как если бы была вызвана прямо на target."
    }]
}, {
    h2: "Документ и объекты страницы",
    p: [{
        h3: "Окружение: DOM, BOM и JS",
        p: "Итак, у нас есть DOM, BOM и, собственно, язык JavaScript, который даёт возможность управлять всем этим.\n" +
        "BOM – это объекты для работы с чем угодно, кроме документа.\n" +
        "\n" +
        "Например:\n" +
        "\n" +
        "Объект navigator содержит общую информацию о браузере и операционной системе. Особенно примечательны два свойства: navigator.userAgent – содержит информацию о браузере и navigator.platform – содержит информацию о платформе, позволяет различать Windows/Linux/Mac и т.п.\n" +
        "Объект location содержит информацию о текущем URL страницы и позволяет перенаправить посетителя на новый URL.\n" +
        "Функции alert/confirm/prompt – тоже входят в BOM." +
        "Далее мы приступим к изучению DOM, поскольку именно документ занимает центральную роль в организации интерфейса, и работа с ним – сложнее всего."
    },{
        h3: "Дерево DOM",
        p: "DOM – это представление документа в виде дерева объектов, доступное для изменения через JavaScript. " +
        "Всего различают 12 типов узлов, но на практике мы работаем с четырьмя из них:\n" +
        "\n" +
        "Документ – точка входа в DOM.\n" +
        "Элементы – основные строительные блоки.\n" +
        "Текстовые узлы – содержат, собственно, текст.\n" +
        "Комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна из JS. "
    },{
        h3: "Работа с DOM из консоли",
        p: "DOM в Elements не совсем соответствует реальному\n" +
        "Отображение DOM во вкладке Elements не совсем соответствует реальному. В частности, там не отображаются пробельные узлы. Это сделано для удобства просмотра. Но мы-то знаем, что они есть.\n" +
        "\n" +
        "С другой стороны, в Elements можно увидеть CSS-псевдоэлементы, такие как ::before, ::after. Это также сделано для удобства, в DOM их не существует. " +
        "Зачастую бывает нужно выбрать элемент DOM и сделать с ним что-то на JavaScript.\n" +
        "\n" +
        "Находясь во вкладке Elements, откройте консоль нажатием Esc (или перейдите на вкладку Console).\n" +
        "\n" +
        "Последний элемент, выбранный во вкладке Elements, доступен в консоли как $0, предыдущий – $1 и так далее. " +
        "Есть и обратная дорожка. Любой элемент из JS-переменной можно посмотреть во вкладке Elements, для этого:\n" +
        "\n" +
        "Выведите эту переменную в консоли, например при помощи console.log.\n" +
        "Кликните на выводе в консоли правой кнопкой мыши.\n" +
        "Выберите соответствующий пункт меню. " +
        "Ещё методы консоли\n" +
        "\n" +
        "Для поиска элементов в консоли есть два специальных метода:\n" +
        "\n" +
        "$$(\"div.my\") – ищет все элементы в DOM по данному CSS-селектору.\n" +
        "$(\"div.my\") – ищет первый элемент в DOM по данному CSS-селектору."
    },{
        h3: "Навигация по DOM-элементам",
        p: "DOM позволяет делать что угодно с HTML-элементом и его содержимым, но для этого нужно сначала нужный элемент получить.\n" +
        "Доступ к DOM начинается с объекта document. Из него можно добраться до любых узлов. " +
        "Сверху documentElement и body\n" +
        "Самые верхние элементы дерева доступны напрямую из document.\n" +
        "HTML = document.documentElement\n" +
        "Первая точка входа – document.documentElement. Это свойство ссылается на DOM-объект для тега html.\n" +
        "BODY = document.body\n" +
        "Вторая точка входа – document.body, который соответствует тегу body.\n" +
        "В современных браузерах (кроме IE8-) также есть document.head – прямая ссылка на head\n" +
        "Есть одна тонкость: document.body может быть равен null\n" +
        "Нельзя получить доступ к элементу, которого еще не существует в момент выполнения скрипта.\n" +
        "В частности, если скрипт находится в head, то в нём недоступен document.body. " +
        "В DOM активно используется null\n" +
        "В мире DOM в качестве значения, обозначающего «нет такого элемента» или «узел не найден», используется не undefined, а null. " +
        "Дети: childNodes, firstChild, lastChild\n" +
        "Здесь и далее мы будем использовать два принципиально разных термина.\n" +
        "Дочерние элементы (или дети) – элементы, которые лежат непосредственно внутри данного. Например, внутри HTML обычно лежат HEAD и BODY.\n" +
        "Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.\n" +
        "Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые. " +
        "Список детей – только для чтения!\n" +
        "Скажем больше – все навигационные свойства, которые перечислены в этой главе – только для чтения. Нельзя просто заменить элемент присвоением childNodes[i] = ....\n" +
        "Изменение DOM осуществляется другими методами, которые мы рассмотрим далее, все навигационные ссылки при этом обновляются автоматически. " +
        "Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу. " +
        "DOM-коллекции, такие как childNodes и другие, которые мы увидим далее, не являются JavaScript-массивами.\n" +
        "В них нет методов массивов, таких как forEach, map, push, pop и других. " +
        "Именно поэтому childNodes и называют «коллекция» или «псевдомассив».\n" +
        "Можно для перебора коллекции использовать обычный цикл for(var i=0; i < elems.length; i++) ... Но что делать, если уж очень хочется воспользоваться методами массива?\n" +
        "Применить метод массива через call/apply:\n" +
        "При помощи Array.prototype.slice сделать из коллекции массив.\n" +
        "Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr с индексами от a до b-1 включительно. Если же вызвать его без аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr. " +
        "Нельзя перебирать коллекцию через for..in\n" +
        "Ранее мы говорили, что не рекомендуется использовать для перебора массива цикл for..in.\n" +
        "Коллекции – наглядный пример, почему нельзя. Они похожи на массивы, но у них есть свои свойства и методы, которых в массивах нет.\n" +
        "К примеру, код ниже должен перебрать все дочерние элементы <html>. Их, естественно, два: <head> и <body>. Максимум, три, если взять ещё и текст между ними. " +
        "Цикл for..in выведет не только ожидаемые индексы 0, 1, 2, по которым лежат узлы в коллекции, но и свойство length (в коллекции оно enumerable), а также функцию item(n) – она никогда не используется, возвращает n-й элемент коллекции, проще обратиться по индексу [n].\n" +
        "В реальном коде нам нужны только элементы, мы же будем работать с ними, а служебные свойства – не нужны. Поэтому желательно использовать for(var i=0; i<elems.length; i++). " +
        "Соседи и родитель\n" +
        "Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling.\n" +
        "Родитель доступен через parentNode. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до document.documentElement, а затем и document. " +
        "Навигационные ссылки, описанные выше, равно касаются всех узлов в документе. В частности, в childNodes сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть.\n" +
        "Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:\n" +
        "children – только дочерние узлы-элементы, то есть соответствующие тегам.\n" +
        "firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы.\n" +
        "previousElementSibling, nextElementSibling – соседи-элементы.\n" +
        "parentElement – родитель-элемент.\n  " +
        "Особые ссылки для таблиц\n" +
        "У конкретных элементов DOM могут быть свои дополнительные ссылки для большего удобства навигации.\n" +
        "Здесь мы рассмотрим таблицу, так как это важный частный случай и просто для примера.\n" +
        "В списке ниже выделены наиболее полезные:\n" +
        "TABLE\n" +
        "table.rows – коллекция строк TR таблицы.\n" +
        "table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT.\n" +
        "table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько.\n" +
        "THEAD/TFOOT/TBODY\n" +
        "tbody.rows – коллекция строк TR секции.\n" +
        "TR\n" +
        "tr.cells – коллекция ячеек TD/TH\n" +
        "tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY\n" +
        "tr.rowIndex – номер строки в таблице\n" +
        "TD/TH\n" +
        "td.cellIndex – номер ячейки в строке "
    },{
        h3: "Поиск: getElement* и querySelector* и не только",
        p: "Есть 6 основных методов поиска элементов DOM:\n" +
        "\n" +
        "Метод\tИщет по...\tИщет внутри элемента?\tПоддержка\n" +
        "getElementById\tid\t-\tвезде\n" +
        "getElementsByName\tname\t-\tвезде\n" +
        "getElementsByTagName\tтег или '*'\t✔\tвезде\n" +
        "getElementsByClassName\tклассу\t✔\tкроме IE8-\n" +
        "querySelector\tCSS-селектор\t✔\tвезде\n" +
        "querySelectorAll\tCSS-селектор\t✔\tвезде\n" +
        "Практика показывает, что в 95% ситуаций достаточно querySelector/querySelectorAll. Хотя более специализированные методы getElement* работают чуть быстрее, но разница в миллисекунду-другую редко играет роль.\n" +
        "Кроме того:\n" +
        "Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору. Он поддерживается большинством браузеров в префиксной форме (ms, moz, webkit).\n" +
        "Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.\n" +
        "Язык запросов XPath поддерживается большинством браузеров, кроме IE, даже 9-й версии, но querySelector удобнее. Поэтому XPath используется редко."
    },{
        h3: "Свойства узлов: тип, тег и содержимое",
        p: "Прямо от Node наследуют текстовые узлы Text, комментарии Comment и элементы Element.\n" +
        "Элементы Element – это ещё не HTML-элементы, а более общий тип, который используется в том числе в XML. От него наследует SVGElement для SVG-графики и, конечно, HTMLElement.\n" +
        "От HTMLElement уже наследуют разнообразные узлы HTML:\n" +
        "Для < input > – HTMLInputElement\n" +
        "Для < body > – HTMLBodyElement\n" +
        "Для < a > – HTMLAnchorElement… и так далее.\n" +
        "Узнать класс узла очень просто – достаточно привести его к строке, к примеру, вывести:\n" +
        " alert( document.body ); // [object HTMLBodyElement]\n " +
        "console.dir(elem) против console.log(elem)\n" +
        "Вывод console.log(elem) и console.dir(elem) различен.\n" +
        "console.log выводит элемент в виде, удобном для исследования HTML-структуры.\n" +
        "console.dir выводит элемент в виде JavaScript-объекта, удобно для анализа его свойств.\n " +
        "Тип узла содержится в его свойстве nodeType.\n" +
        "Как правило, мы работаем всего с двумя типами узлов:\n" +
        "Элемент.\n" +
        "Текстовый узел.\n" +
        "На самом деле типов узлов гораздо больше. Строго говоря, их 12, и они описаны в спецификации с древнейших времён, см. DOM Уровень 1 " +
        "Тег: nodeName и tagName\n" +
        "Существует целых два свойства: nodeName и tagName, которые содержат название(тег) элемента узла.\n" +
        "Название HTML-тега всегда находится в верхнем регистре. " +
        "В XHTML nodeName может быть не в верхнем регистре\n" +
        "У браузера есть два режима обработки документа: HTML и XML-режим. Обычно используется режим HTML.\n" +
        "XML-режим включается, когда браузер получает XML-документ через XMLHttpRequest(технология AJAX) или при наличии заголовка Content-Type: application/xml+xhtml.\n" +
        "В XML-режиме сохраняется регистр и nodeName может выдать «body» или даже «bOdY» – в точности как указано в документе. XML-режим используют очень редко. " +
        "Какая разница между tagName и nodeName ?\n" +
        "Разница отражена в названиях свойств, но неочевидна.\n" +
        "Свойство tagName есть только у элементов Element (в IE8- также у комментариев, но это ошибка в браузере).\n" +
        "Свойство nodeName определено для любых узлов Node, для элементов оно равно tagName, а для не-элементов обычно содержит строку с типом узла.\n" +
        "Таким образом, при помощи tagName мы можем работать только с элементами, а nodeName может что-то сказать и о других типах узлов. " +
        "позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать. " +
        "Добавление innerHTML+= осуществляет перезапись\n" +
        "Синтаксически, можно добавить текст к innerHTML через +=: " +
        "Если в innerHTML есть тег script – он не будет выполнен. " +
        "Изменить outerHTML элемента невозможно. " +
        ""
    },{
        h3: "Современный DOM: полифиллы",
        p: ""
    },{
        h3: "Атрибуты и DOM-свойства",
        p: ""
    },{
        h3: "Методы contains и compareDocumentPosition",
        p: ""
    },{
        h3: "Добавление и удаление узлов",
        p: ""
    },{
        h3: "Мультивставка: insertAdjacentHTML и DocumentFragment",
        p: ""
    },{
        h3: "Метод document.write",
        p: ""
    },{
        h3: "Стили, getComputedStyle",
        p: ""
    },{
        h3: "Размеры и прокрутка элементов",
        p: ""
    },{
        h3: "Размеры и прокрутка страницы",
        p: ""
    },{
        h3: "Координаты в окне",
        p: ""
    },{
        h3: "Координаты в документе",
        p: ""
    },{
        h3: "Итого",
        p: ""
    }]
}, {
    h2: "Основы работы с событиями",
    p: [{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    }]
}, {
    h2: "События в деталях",
    p: [{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    }]
}, {
    h2: "Формы, элементы управления",
    p: [{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    }]
}, {
    h2: "Создание графических компонентов",
    p: [{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    },{
        h3: "",
        p: ""
    }]
}
];

//myCode
var li = document.querySelectorAll("li");
var contentBarContainer = document.querySelector("#contentBar");

for (var i = 0; i < li.length; i++) {
    (function (a, iterator) {
        a.onclick = function () {
            /**
             * Clear element before appending new child
             */
            while (contentBarContainer.firstChild) {
                contentBarContainer.removeChild(contentBarContainer.firstChild);
            }
            var fragment = document.createDocumentFragment();
            createHtmlAssembly(myText[iterator], fragment);
            if (Array.isArray(myText[iterator].p) === true) {
                for (var alternative = 0; alternative < myText[iterator].p.length; alternative++) {
                    createHtmlAssembly(myText[iterator].p[alternative], fragment);
                }
            }
            contentBarContainer.appendChild(fragment);
        }
    }(li[i], i));
};
function createHtmlElement (tag, text) {
    var elem = document.createElement(tag);
    elem.innerHTML = text;
    return elem;
};
function createHtmlAssembly (tagName, fragment) {
    for (elem in tagName) {
        if (Array.isArray(tagName[elem]) === false) {
            fragment.appendChild(createHtmlElement(elem, tagName[elem]));
        }
    };
};
