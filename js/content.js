var myText = [{
    h2: 'Введение',
    p: [{
        h3: 'Введение в JavaScript',
        p: '1.Введение в JavaScript дает нам общее понятие о создании, общей истории и развити JavaScript'
    }, {
        h3: 'Справочники и спецификации',
        p: '2.Подраздел справочники и спецификации дает нам информацию о том, какие особенности у каких браузеров и где можно найти корректную документацию касаемо JavaScript'

    }, {
        h3: 'Редакторы для кода',
        p: '3.В пункте Редакторы для кода нам представляется возможность ознакомиться с редакторами кода и ссылками на оф. страницы для скачивания.'

    }, {

        h3: "Консоль разработчика",
        p: "4.Пункт Консоль разработчика в кратце рассказывает нам на что стоит обратить внимание при проверке кода через консоль."
    }]
}, {
    h2: "Основы JavaScript",
    p: [{

        h3: "Привет мир!",
        p: "В данной статье нас знакомяс с особенностями месторасположения тега script и корректным размещением коментариев и тд."

    }, {
        h3: "Внешние скрипты, порядок исполнения",
        p: "Данная статья обучает нас подключению внешних скриптов и корректирует нас в их особенностях и различиях при загрузке на страницу а так же рассказывает, как они непосредственно влияют на саму загрузку страницы"

    }, {
        h3: "Структура кода ",
        p: "Данная статья обучит нас как корректнее делать разметку кода, переносы и разбитие на строки"

    }, {
        h3: "Современный стандарт, use strict",
        p: "Use strict строка- дает нам возможность писать более современный код, но в то же время имеет свои особенности в использовании..."

    }, {
        h3: "Переменные",
        p: "На мой взгляд-одна из важнейших статей в данном разделе! Благодаря ей мы более детально поймем как работать с переменными, заполнять их информацией и использовать ее в будущем."

    }, {
        h3: "Правильный выбор имени переменной",
        p: "Правильный выбор имени переменных-одно из основных базовых  пониманий того, что в ней будет храниться либо для чего она может быть использована"

    }, {
        h3: "Шесть типов данных, typeof",
        p: "В данной статье нас в кратце ознакамливают с 5 основными примитивными  типами данных и обьектами"

    }, {
        h3: "Операторы",
        p: "Исходя из школьных программ все мы помним про математические елементы вычисления. Но в данной статье афтор открывает нам их новые возможности и раскрывает секреты использования в програмировании"

    }, {
        h3: "Условные операторы: if,?",
        p: "Данная статья обучает нас различиям методов использования операторов а так же дает нам возможность понять, как грамотно выстроить логическую цепочку действий при различных ответах(либо без них)."

    }, {
        h3: "Функции",
        p: "Данный ряд статей нам рассказывает о том, как грамотно создавать и использовать функции и с их помощью делать клиентскую сторону более динамичной."
    }]
}, {
    h2: "Качество кода",
    p: [{
        h3: "Отладка в chrome",
        p: "В данном пункте нам рассказывается о корректном тестировании кода, его шифровании и отладке в браузере. О том, куда стоит обратить внимание при работе с данным браузером."
    }, {
        h3: "Советы по стилю кода",
        p: "Мы переходим к стилю кода и его корректному написанию. В этом разделе нам предоставят таблицу со всеми нареканиями и замечаниями которые могут навредить нашему написанию кода и его формированию(дальнейшему использованию) на странице"
    }, {
        h3: "Как писать неподдерживаемый код?",
        p: "Для написания неподдерживаемого кода нужно усложнить его понятность для окружающих(уловки на эту тему указаны в данном разделе) а так же нам дается краткая екскурсия того, как этот код писать так, чтоб он был понятен только вам"
    }, {
        h3: "Автоматические тесты при помощи chai и mocha",
        p: "С данной главой я рекомендовал бы ознакомиться в начале своей деятельности как програмиста. Ведь писочницу можно использовать как тесты (которые гарантируют правильность кода),документацию по функциям и описанию их конкретных задач"
    }]
}, {
    h2: "Структуры данных",
    p: [{
        h3: "Введение в методы и свойства",
        p: "Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку». К примеру .length укажет нам длинну масива а str.toUpperCase() вернет строку в ВЕРХНЕМ РЕГИСТРЕ, num.toFixed(n) округлитель чисел в котором num-число а n количество цифр после запятой"
    }, {
        h3:"Числа",
        p:"Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа, В JavaScript существует числовое значение бесконечность Infinity.\n" +
        "Ошибка вычислений дает NaN Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p"
    },{
        h3:"Строки",
        p:"\\b\tBackspace\n" +
        "\\f\tForm feed\n" +
        "\\n\tNew line\n" +
        "\\r\tCarriage return\n" +
        "\\t\tTab" +
        "Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний" +
        "Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция])"
    },{
        h3:"Обьекты как ассоциальные массивы",
        p:"Доступ к элементам осуществляется:\n" +
		"Напрямую по ключу obj.prop = 5\n" +
		"Через переменную, в которой хранится ключ\n" +
		"Удаление ключей: delete obj.name"
    },{
        h3:"Объекты: перебор свойств",
        p:"Цикл по ключам: for (key in obj)\n" +
		"Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах)\n" +
		"Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +"
    },{
        h3:"Объекты: передача по ссылке",
        p:"Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.\n" +
		"Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.\n" +
		"Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью."
    },{
        h3:"Массивы с числовыми индексами",
        p:"length – длина массива. Если точнее, то последний индекс массива плюс 1. Если её уменьшить вручную, то массив укоротится. Если length больше реального количества элементов, то отсутствующие элементы равны undefined \n" +
		"arr.push(элемент1, элемент2...) добавляет элементы в конец. \n" +
		"var elem = arr.pop() удаляет и возвращает последний элемент \n" +
		"arr.unshift(элемент1, элемент2...) добавляет элементы в начало. \n" +
		"var elem = arr.shift() удаляет и возвращает первый элемент \n" +
		"Эти операции перенумеровывают все элементы, поэтому работают медленно"
    },{
        h3:"Массивы: методы",
        p:"push/pop, shift/unshift, splice – для добавления и удаления элементов.\n" +
		"join/split – для преобразования строки в массив и обратно.\n" +
		"slice – копирует участок массива.\n" +
		"sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.\n" +
		"reverse – меняет порядок элементов на обратный.\n" +
		"concat – объединяет массивы.\n" +
		"indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).\n" +
		"Дополнительно: Object.keys(arr) возвращает массив свойств объекта."
    },{
		h3:"Массив: перебирающие методы",
		p:"forEach – для перебора массива.\n" +
		"filter – для фильтрации массива.\n" +
		"every/some – для проверки массива.\n" +
		"map – для трансформации массива в массив.\n" +
		"reduce/reduceRight – для прохода по массиву с вычислением значения."
	},{
		h3:"Псевдомассив аргументов(arguments)",
		p:"Полный список аргументов, с которыми вызвана функция, доступен через arguments.\n" +
        "Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет.\n" +
        "В старом стандарте было свойство arguments.callee со ссылкой на текущую функцию, а также свойство arguments.callee.caller, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при use strict обращение к ним приведёт к ошибке.\n" +
        "Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||."
	},{
		h3:"Дата и Время",
		p:"new Date(year, month, date, hours, minutes, seconds, ms)\n" +
        "Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице\n" +
        "Получение компонентов даты\n" +
        "Для доступа к компонентам даты-времени объекта Date используются следующие методы:\n" +
        "getFullYear()\n" +
        "Получить год (из 4 цифр)\n" +
        "getMonth()\n" +
        "Получить месяц, от 0 до 11.\n" +
        "getDate()\n" +
        "Получить число месяца, от 1 до 31.\n" +
        "getHours(), getMinutes(), getSeconds(), getMilliseconds()\n" +
        "Получить соответствующие компоненты.\n" +
        "getDay()\n" +
        "Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).\n" +
        "Все методы, указанные выше, возвращают результат для местной временной зоны.\n" +
        "Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после get вставляется UTC.\n" +
        "Установка компонентов даты\n" +
        "Следующие методы позволяют устанавливать компоненты даты и времени:\n" +
        "setFullYear(year [, month, date])\n" +
        "setMonth(month [, date])\n" +
        "setDate(date)\n" +
        "setHours(hour [, min, sec, ms])\n" +
        "setMinutes(min [, sec, ms])\n" +
        "setSeconds(sec [, ms])\n" +
        "setMilliseconds(ms)\n" +
        "setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)\n" +
        "console.time(метка) – включить внутренний хронометр браузера с меткой.\n" +
        "console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.\n" +
        "Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date (кроме IE8-)\n" +
        "Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее."
	}]
}, {
    h2: "Замыкания",
    p:[{
        h3: "Глобальный объект",
        p: "Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные»\n" +
        "в глобальных обьектах Фигурные скобки, которые используются в for, while, if, в отличие от объявлений функции, имеют «декоративный» характер\n" +
        "В результате инициализации, к началу выполнения кода:\n" +
        "Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.\n" +
        "Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них."
    },{
        h3: "Замыкания, функции изнутри",
        p: "Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.\n" +
        "Мы будем называть этот объект «лексическое окружение» или просто «объект переменных».\n" +
        "При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.\n" +
        "В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.\n" +
        "Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window.\n" +
        "При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.\n" +
        "Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.\n" +
        "Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.\n" +
        "Тем не менее, в JavaScript есть небольшая терминологическая особенность.\n" +
        "Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.\n" +
        "Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных."
    },{
        h3: "[[Scope]] для new Function",
        p: "При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.\n" +
        "Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров."
    },{
        h3: "Локальные переменные для объекта",
        p: "getNext() – получить следующее значение, то, что раньше делал вызов counter().\n" +
        "set(value) – поставить значение.\n" +
        "reset() – обнулить счётчик\n" +
        "ПРИМЕР :counter.set(5);\n" +
        "alert( counter() ); // 5"
    },{
        h3: "Модули через замыкания",
        p: "на месте» разрешено вызывать только Function Expression.\n" +
        "Общее правило таково:\n" +
        "Если браузер видит function в основном потоке кода – он считает, что это Function Declaration.\n" +
        "Если же function идёт в составе более сложного выражения, то он считает, что это Function Expression.\n" +
        "Для этого нужно завернуть функцию в скобки и браузер поймет , что у нас Function Expression, который по правилам JavaScript можно вызвать «на месте»." +
        "Можно показать это другим способом, например поставив перед функцией оператор \"+\" или \"!\" перед функцией" +
        "Модуль при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.\n" +
        "Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание.\n" +
        "Например, defaults из примера выше имеет доступ к assignDefaults.\n" +
        "Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.\n" +
        "Можно придумать и много других вариаций такого подхода. В конце концов, «модуль» – это всего лишь функция-обёртка для скрытия переменных."
    },{
        h3: "Управление памятью в JavaScript",
        p: "Для очистки памяти от недостижимых значений в браузерах используется автоматический Сборщик мусора (англ. Garbage collection, GC), встроенный в интерпретатор, который наблюдает за объектами и время от времени удаляет недостижимые\n" +
        "Есть одно упрощение для работы с памятью: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка».\n" +
        "Верно – в том плане, что если ссылок на значение нет, то память из-под него очищается.\n" +
        "Неверно – в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти.\n" +
        "Такая ситуация возникает с объектами, которые ссылаются друг на друга:\n" +
        "var vasya = {};\n" +
        "var petya = {};\n" +
        "vasya.friend = petya;\n" +
        "petya.friend = vasya;\n" +
        "vasya = petya = null;"
    },{
        h3: "Устаревшая конструкция \"with\"",
        p: "Свойства из разных объектов используются как обычные переменные… Магия! Порядок поиска переменных в выделенном коде: size => obj => window.\n" +
        "При использовании with, как и во вложенных функциях – переменная изменяется в той области, где была найдена.\n" +
        "Вместо with рекомендуется использовать временную переменную\n" +
        "Конструкция with(obj) { ... } использует obj как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в obj.\n" +
        "Конструкция with устарела и не рекомендуется по ряду причин. Избегайте её."
    }]
}, {
    h2: "Методы объектов и контекст вызова",
    p: [{
        h3:"Методы объектов, this",
        p: "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.\n" +
        "Через this метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком\n" +
        "Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.\n" +
        "Значение this называется контекстом вызова и будет определено в момент вызова функции.\n" +
        "Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this\n" +
        "Если функция использует this – это подразумевает работу с объектом. Но и прямой вызов func() технически возможен.\n" +
        "Как правило, такая ситуация возникает при ошибке в разработке.\n" +
        "При этом this получает значение window, глобального объекта\n" +
        "А в режиме use strict вместо глобального объекта this будет undefined\n" +
        "Контекст this никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).\n" +
        "Любой более хитрый вызов приведёт к потере контекста"
    },{
        h3:"Преобразование объектов: toString и valueOf",
        p:"Строковое преобразование – если объект выводится через alert(obj).\n" +
        "Результатом toString может быть любой примитив\n" +
        "Метод toString не обязан возвращать именно строку.\n" +
        "Его результат может быть любого примитивного типа. Например, это может быть число если обьект преобразования имеет числовые индексы\n" +
        "Численное преобразование – при арифметических операциях, сравнении с примитивом.\n" +
        "Для численного преобразования объекта используется метод valueOf, а если его нет – то toString\n" +
        "Логическое преобразование – при if(obj) и других логических операциях. И приравнивается к true\n" +
        "Проще всего – с логическим преобразованием.\n" +
        "Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}\n" +
        "Две стадии преобразования\n" +
        "Объект Date, по историческим причинам, является исключением.\n" +
        "Бинарный оператор плюс + обычно использует числовое преобразование и метод valueOf. Как мы уже знаем, если подходящего valueOf нет (а его нет у большинства объектов), то используется toString, так что в итоге преобразование происходит к строке. Но если есть valueOf, то используется valueOf.\n" +
        "У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.\n" +
        "…Но оператор + для Date использует именно toString (хотя должен бы valueOf).\n" +
        "Это и есть исключение\n" +
        "В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val."
    },{
        h3:"Создание объектов через \"new\"",
        p:"Обычный синтаксис {...} позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.\n" +
        "Для этого используют «функции-конструкторы», запуская их при помощи специального оператора new.\n" +
        "Заметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи new. Как-то особым образом указывать, что она – конструктор – не надо.\n" +
        "Но, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal.\n" +
        "Детальнее – функция, запущенная через new, делает следующее:\n" +
        "Создаётся новый пустой объект.\n" +
        "Ключевое слово this получает ссылку на этот объект.\n" +
        "Функция выполняется. Как правило, она модифицирует this (т.е. этот новый объект), добавляет методы, свойства.\n" +
        "Возвращается this.\n" +
        "Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.\n" +
        "Но если явный вызов return всё же есть, то применяется простое правило:\n" +
        "При вызове return с объектом, будет возвращён он, а не this.\n" +
        "При вызове return с примитивным значением, оно будет отброшено.\n" +
        "Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this\n" +
        "Кстати, при вызове new без аргументов скобки можно не ставить(НО ЭТО БУДЕТ ЯВЛЯТЬСЯ ПЛОХИМ СТИЛЕМ НАПИСАНИЯ КОДА)"
    },{
        h3:"Дескрипторы, геттеры и сеттеры свойств",
        p:"Основной метод для управления свойствами – Object.defineProperty.\n" +
        "Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.\n" +
        "Синтаксис:\n" +
        "Object.defineProperty(obj, prop, descriptor)\n" +
        "Аргументы:\n" +
        "obj\n" +
        "Объект, в котором объявляется свойство.\n" +
        "prop\n" +
        "Имя свойства, которое нужно объявить или модифицировать.\n" +
        "descriptor\n" +
        "Дескриптор – объект, который описывает поведение свойства.\n" +
        "В нём могут быть следующие поля:\n" +
        "value – значение свойства, по умолчанию undefined\n" +
        "writable – значение свойства можно менять, если true. По умолчанию false.\n" +
        "configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.\n" +
        "enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.\n" +
        "get – функция, которая возвращает значение свойства. По умолчанию undefined.\n" +
        "set – функция, которая записывает значение свойства. По умолчанию undefined.\n" +
        "Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.\n" +
        "Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:\n" +
        "Заметим, что без use strict операция записи «молча» не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.\n" +
        "Свойство, скрытое для for…in\n" +
        "Встроенный метод toString, как и большинство встроенных методов, не участвует в цикле for..in. Это удобно, так как обычно такое свойство является «служебным».\n" +
        "К сожалению, свойство toString, объявленное обычным способом, будет видно в цикле for..in\n" +
        "Object.keys(obj), Object.getOwnPropertyNames(obj)\n" +
        "Возвращают массив – список свойств объекта.\n" +
        "Object.keys возвращает только enumerable-свойства.\n" +
        "Object.getOwnPropertyNames – возвращает все:\n" +
        "Object.getOwnPropertyDescriptor(obj, prop)\n" +
        "Возвращает дескриптор для свойства obj[prop].\n" +
        "Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений\n" +
        "…И несколько методов, которые используются очень редко:\n" +
        "Object.preventExtensions(obj)\n" +
        "Запрещает добавление свойств в объект.\n" +
        "Object.seal(obj)\n" +
        "Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.\n" +
        "Object.freeze(obj)\n" +
        "Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.\n" +
        "Object.isExtensible(obj)\n" +
        "Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.\n" +
        "Object.isSealed(obj)\n" +
        "Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.\n" +
        "Object.isFrozen(obj)\n" +
        "Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.\n"
    },{
        h3:"Статические и фабричные методы",
        p:"Преимущества использования фабричных методов:\n" +
        "\n" +
        "Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.\n" +
        "Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.\n" +
        "Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.\n" +
        "Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.\n" +
        "А в остальных случаях отличная альтернатива – фабричные методы.\n" +
        "Статические свойства и методы объекта удобно применять в следующих случаях:\n" +
        "Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.\n" +
        "Методы, не привязанные к конкретному объекту, например сравнение.\n" +
        "Вспомогательные методы, которые полезны вне объекта, например для форматирования даты."
    },{
        h3:"Явное указание this: \"call\", \"apply\"",
        p:"При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.\n" +
        "Это называется «одалживание метода» (на англ. method borrowing).\n" +
        "Используем эту технику для упрощения манипуляций с arguments.\n" +
        "Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет.\n" +
        "Метод apply\n" +
        "Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply.\n" +
        "Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка\n" +
        "Значение this устанавливается в зависимости от того, как вызвана функция:\n" +
        "При вызове функции как метода:\n" +
        "obj.func(...)    // this = obj\n" +
        "obj[\"func\"](...)\n" +
        "При обычном вызове:\n" +
        "func(...) // this = window (ES3) /undefined (ES5)\n" +
        "В new:\n" +
        "new func() // this = {} (новый объект)\n" +
        "Явное указание:\n" +
        "func.apply(context, args) // this = context (явная передача)\n" +
        "func.call(context, arg1, arg2, ...)"
    },{
        h3:"Привязка контекста и карринг: \"bind\"",
        p:"Функция сама по себе не запоминает контекст выполнения.\n" +
        "Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию:\n" +
        "setTimeout(function() {\n" +
        "  obj.func();\n" +
        "})\n" +
        "…Либо использовать bind:\n" +
        "setTimeout(obj.func.bind(obj));\n" +
        "Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.\n" +
        "Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз."
    },{
        h3:"Функции-обёртки, декораторы",
        p:"Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.\n" +
        "Декораторы можно не только повторно использовать, но и комбинировать!\n" +
        "Это кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода «фичи» или возможности, которые можно «нацепить» на любую функцию. Можно один, а можно несколько.\n" +
        "Скажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.\n" +
        "Предлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними."
    }]
}, {
    h2: "Некторорые другие возможности",
    p: [{
        h3:"Типы данных: [[Class]], instanceof и утки",
        p:" Секретное свойство [[Class]]\n" +
        "Для встроенных объектов есть одна «секретная» возможность узнать их тип, которая связана с методом toString.\n" +
        "Во всех встроенных объектах есть специальное свойство [[Class]], в котором хранится информация о его типе или конструкторе.\n" +
        "Оно взято в квадратные скобки, так как это свойство – внутреннее. Явно получить его нельзя, но можно прочитать его «в обход», воспользовавшись методом toString стандартного объекта Object.\n" +
        "Его внутренняя реализация выводит [[Class]] в небольшом обрамлении, как \"[object значение]\".\n" +
        "Оператор instanceof позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.\n" +
        "Для написания полиморфных (это удобно!) функций нам нужна проверка типов.\n" +
        "Для примитивов с ней отлично справляется оператор typeof.\n" +
        "У него две особенности:\n" +
        "Он считает null объектом, это внутренняя ошибка в языке.\n" +
        "Для функций он возвращает function, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.\n" +
        "Для встроенных объектов мы можем получить тип из скрытого свойства [[Class]], при помощи вызова {}.toString.call(obj).slice(8, -1). Для конструкторов, которые объявлены нами, [[Class]] всегда равно \"Object\".\n" +
        "Оператор obj instanceof Func проверяет, создан ли объект obj функцией Func, работает для любых конструкторов. Более подробно мы разберём его в главе Проверка класса: \"instanceof\".\n" +
        "И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется «утиная типизация»."
    },{
        h3:"Формат JSON, метод toJSON",
        p:" Данные в формате JSON (RFC 4627) представляют собой:\n" +
        "JavaScript-объекты { ... } или\n" +
        "Массивы [ ... ] или\n" +
        "Значения одного из типов:\n" +
        "строки в двойных кавычках,\n" +
        "число,\n" +
        "логическое значение true/false,\n" +
        "null.\n" +
        " Основные методы для работы с JSON в JavaScript – это:\n" +
        "JSON.parse – читает объекты из строки в формате JSON.\n" +
        "JSON.stringify – превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.\n" +
        " Вызов JSON.parse(str) превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.\n" +
        "Объекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках.\n" +
        "Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.\n" +
        "Есть нестандартное расширение формата JSON, которое называется JSON5 и как раз разрешает ключи без кавычек, комментарии и т.п, как в обычном JavaScript. На данном этапе это отдельная библиотека.\n" +
        " Метод JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.\n" +
        "При сериализации объекта вызывается его метод toJSON.\n" +
        "Если такого метода нет – перечисляются его свойства, кроме функций.\n" +
        "Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод toJSON. Его результат в данном случае – строка в таймзоне UTC.\n"
    },{
        h3:"setTimeout и setInterval",
        p:" Методы setInterval(func, delay) и setTimeout(func, delay) позволяют запускать func регулярно/один раз через delay миллисекунд.\n" +
        "Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом clearInterval/clearTimeout.\n" +
        "В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо setInterval используют рекурсивный setTimeout.\n" +
        "Минимальная задержка по стандарту составляет 4 мс. Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки.\n" +
        "В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.\n" +
        "Браузерных особенностей почти нет, разве что вызов setInterval(..., 0) с нулевой задержкой в IE недопустим, нужно указывать setInterval(..., 1)."
    },{
        h3:"Запуск кода из строки: eval",
        p:" Функция eval(code) позволяет выполнить код, переданный ей в виде строки.\n" +
        "Этот код будет выполнен в текущей области видимости.\n" +
        "При вызове eval имеет полный доступ к локальным переменным.\n" +
        "Это означает, что текущие переменные могут быть изменены или дополнены\n" +
        " В строгом режиме eval имеет свою область видимости\n" +
        "В строгом режиме функционал eval чуть-чуть меняется.\n" +
        "При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу\n" +
        "Неграмотное использование eval\n" +
        "Начнём с того, что eval применяется очень редко. Действительно редко. Есть даже такое выражение «eval is evil» (eval – зло).\n" +
        "Причина проста: когда-то JavaScript был гораздо более слабым языком, чем сейчас, и некоторые вещи без eval было сделать невозможно. Но те времена давно прошли. И теперь найти тот случай, когда действительно надо выполнить код из строки – это надо постараться.\n" +
        "Но если вы действительно знаете, что это именно тот случай и вам необходим eval – есть ряд вещей, которые нужно иметь в виду.\n" +
        "Доступ к локальным переменным – худшее, что можно сделать при eval.\n" +
        "Дело в том, что локальные переменные могут быть легко переименованы\n" +
        "JSON и eval\n" +
        "В браузерах IE7- не было методов JSON.stringify и JSON.parse, поэтому работа с JSON происходила через eval.\n" +
        "Этот способ работы с JSON давно устарел, но его можно встретить кое-где в старом коде, так что для примера рассмотрим его.\n" +
        "Вызов eval(code) выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.\n" +
        "Осторожно, злой JSON!\n" +
        "Если мы получаем JSON из недоверенного источника, например с чужого сервера, то разбор через eval может быть опасен.\n" +
        "Например, чужой сервер может быть взломан (за свой-то код мы отвечаем, а за чужой – нет), и вместо JSON вставлен злонамеренный JavaScript-код.\n" +
        "Поэтому рекомендуется, всё же, использовать JSON.parse.\n" +
        "При разборе через JSON.parse некорректный JSON просто приведёт к ошибке, а вот при разборе через eval этот код реально выполнится, он может вывести что-то на странице, перенаправить посетителя куда-то и т.п.\n"
    },{
        h3:"Перехват ошибок, \"try..catch\"",
        p:" Обработка ошибок – большая и важная тема.\n" +
        "В JavaScript для этого предусмотрены:\n" +
        "Конструкция try..catch..finally – она позволяет обработать произвольные ошибки в блоке кода.\n" +
        "Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего.\n" +
        "Кроме того, иногда проверить просто невозможно, например JSON.parse(str) не позволяет «проверить» формат строки перед разбором. В этом случае блок try..catch необходим.\n" +
        "Полный вид конструкции:\n" +
        "          try {\n" +
        "   .. пробуем выполнить код ..\n" +
        "} catch(e) {\n" +
        "   .. перехватываем исключение ..\n" +
        "} finally {\n" +
        "   .. выполняем всегда ..\n" +
        "}\n" +
        "Возможны также варианты try..catch или try..finally.\n" +
        "Оператор throw err генерирует свою ошибку, в качестве err рекомендуется использовать объекты, совместимые с встроенным типом Error, содержащие свойства message и name.\n" +
        "Кроме того, мы рассмотрели некоторые важные приёмы:\n" +
        "Проброс исключения – catch(err) должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные – пробрасывать дальше через throw err.\n" +
        "Определить, нужная ли это ошибка, можно, например, по свойству name.\n" +
        "Оборачивание исключений – функция, в процессе работы которой возможны различные виды ошибок, может «обернуть их» в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы, при необходимости, можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования.\n" +
        "В window.onerror можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис."
    }]
}, {
    h2: "ООП в функциональном стиле",
    p: [{
        h3:"Введение",
        p:"ООП – это не просто объекты\n" +
        "В JavaScript объекты часто используются просто как коллекции.\n" +
        "Например, встроенный объект Math содержит функции (Math.sin, Math.pow, …) и данные (константа Math.PI).\n" +
        "При таком использовании объектов мы не можем сказать, что «применён объектно-ориентированный подход». В частности, никакую «единую сущность» Math из себя не представляет, это просто коллекция независимых функций с общим префиксом Math.\n" +
        "Класс в ООП\n" +
        "Классом в объектно-ориентированной разработке называют шаблон/программный код, предназначенный для создания объектов и методов.\n" +
        "В JavaScript классы можно организовать по-разному. Говорят, что класс User написан в «функциональном» стиле. Далее мы также увидим «прототипный» стиль"
    },{
        h3:"Внутренний и внешний интерфейс",
        p:" Внутренний и внешний интерфейс\n" +
        "В программировании мы будем разделять методы и свойства объекта на две группы:\n" +
        "Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).\n" +
        "Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными».\n" +
        "Шаг 1: публичное и приватное свойство\n" +
        "Шаг 2: публичный и приватный методы\n" +
        "Шаг 3: константа\n" +
        "Шаг 4: доступ к объекту из внутреннего метода"
    },{
        h3:"Геттеры и сеттеры",
        p:" Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют «сеттер» (setter method).\n" +
		"Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию – «геттер» (getter method).\n" +
		"Для большего удобства иногда делают единый метод, который называется так же, как свойство и отвечает и за запись, и за чтение.При вызове без параметров такой метод возвращает свойство, а при передаче параметра – назначает его."
    },{
        h3:"Функциональное наследование",
        p:" Организация наследования, которая описана в этой главе, называется «функциональным паттерном наследования».\n" +
        "Её общая схема (кратко):\n" +
        "Объявляется конструктор родителя Machine. В нём могут быть приватные (private), публичные (public) и защищённые (protected) свойства\n" +
        "Для наследования конструктор потомка вызывает родителя в своём контексте через apply. После чего может добавить свои переменные и методы \n" +
        "свойства, полученные от родителя, можно перезаписать своими. Но обычно требуется не заменить, а расширить метод родителя. Для этого он предварительно копируется в переменную\n" +
        "Строку можно упростить до parentProtected(args), если метод родителя не использует this, а, например, привязан к var self = this\n" +
        "Надо сказать, что способ наследования, описанный в этой главе, используется нечасто.\n" +
        "В следующих главах мы будем изучать прототипный подход, который обладает рядом преимуществ.\n" +
        "Но знать и понимать его необходимо, поскольку во многих существующих библиотеках классы написаны в функциональном стиле, и расширять/наследовать от них можно только так"
    }]
}, {
    h2: "ООП в прототипном стиле",
    p:[{
        h3:"Прототип объекта",
        p:"Методы для работы с proto\n" +
        "В современных браузерах есть два дополнительных метода для работы с __proto__. Зачем они нужны, если есть __proto__? В общем-то, не очень нужны, но по историческим причинам тоже существуют.\n" +
        "Чтение: Object.getPrototypeOf(obj)\n" +
        "Возвращает obj.__proto__ (кроме IE8-)\n" +
        "Запись: Object.setPrototypeOf(obj, proto)\n" +
        "Устанавливает obj.__proto__ = proto (кроме IE10-).\n" +
        "Кроме того, есть ещё один вспомогательный метод:\n" +
        "Создание объекта с прототипом: Object.create(proto, descriptors)\n" +
        "Создаёт пустой объект с __proto__, равным первому аргументу (кроме IE8-), второй необязательный аргумент может содержать дескрипторы свойств.\n" +
        "В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства __proto__.\n" +
        "При установке свойства rabbit.__proto__ = animal говорят, что объект animal будет «прототипом» rabbit.\n" +
        "При чтении свойства из объекта, если его в нём нет, оно ищется в __proto__. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj.\n" +
        "Несколько прототипов одному объекту присвоить нельзя, но можно организовать объекты в цепочку, когда один объект ссылается на другой при помощи __proto__, тот ссылается на третий, и так далее.\n" +
        "В современных браузерах есть методы для работы с прототипом:\n" +
        "Object.getPrototypeOf(obj) (кроме IE8-)\n" +
        "Object.setPrototypeOf(obj, proto) (кроме IE10-)\n" +
        "Object.create(proto, descriptors) (кроме IE8-)\n" +
        "Возможно, вас смущает недостаточная поддержка __proto__ в старых IE. Но это не страшно. В последующих главах мы рассмотрим дополнительные методы работы с __proto__, включая те, которые работают везде.\n" +
        "Также мы рассмотрим, как свойство __proto__ используется внутри самого языка JavaScript и как организовать классы с его помощью."
    },{
        h3:"Свойство F.prototype и создание объектов через new",
        p:"Самым очевидным решением является назначение __proto__ в конструкторе.\n" +
        "Недостаток этого подхода – он не работает в IE10-.\n" +
        "К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ.\n" +
        "Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.\n" +
        "При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.\n" +
        "Свойство prototype имеет смысл только у конструктора\n" +
        "Свойство с именем prototype можно указать на любом объекте, но особый смысл оно имеет, лишь если назначено функции-конструктору.\n" +
        "Само по себе, без вызова оператора new, оно вообще ничего не делает, его единственное назначение – указывать __proto__ для новых объектов.\n" +
        "Значением prototype может быть только объект\n" +
        "Технически, в это свойство можно записать что угодно.\n" +
        "Однако, при работе new, свойство prototype будет использовано лишь в том случае, если это объект. Примитивное значение, такое как число или строка, будет проигнорировано. \n" +
        "Свойство constructor\n" +
        "У каждой функции по умолчанию уже есть свойство prototype.\n" +
        "Оно содержит объект такого вида:\n" +
        "function Rabbit() {}\n" +
        "Rabbit.prototype = {\n" +
        "  constructor: Rabbit\n" +
        "};\n" +
        "В коде выше я создал Rabbit.prototype вручную, но ровно такой же – генерируется автоматически\n" +
        "Свойство constructor легко потерять\n" +
        "JavaScript никак не использует свойство constructor. То есть, оно создаётся автоматически, а что с ним происходит дальше – это уже наша забота. В стандарте прописано только его создание.\n" +
        "В частности, при перезаписи Rabbit.prototype = { jumps: true } свойства constructor больше не будет.\n" +
        "Сам интерпретатор JavaScript его в служебных целях не требует, поэтому в работе объектов ничего не «сломается». Но если мы хотим, чтобы возможность получить конструктор, всё же, была, то можно при перезаписи гарантировать наличие constructor вручную:\n" +
        "Rabbit.prototype = {\n" +
        "  jumps: true,\n" +
        "  constructor: Rabbit\n" +
        "};\n" +
        "Либо можно поступить аккуратно и добавить свойства к встроенному prototype без его замены:\n" +
        "// сохранится встроенный constructor\n" +
        "Rabbit.prototype.jumps = true\n" +
        "Эмуляция Object.create для IE8-\n" +
        "Как мы только что видели, с конструкторами всё просто, назначить прототип можно кросс-браузерно при помощи F.prototype.\n" +
        "Теперь небольшое «лирическое отступление» в область совместимости.\n" +
        "Прямые методы работы с прототипом отсутствуют в старых IE, но один из них – Object.create(proto) можно эмулировать, как раз при помощи prototype. И он будет работать везде, даже в самых устаревших браузерах\n" +
        "Для произвольной функции – назовём её Person, верно следующее:\n" +
        "Прототип __proto__ новых объектов, создаваемых через new Person, можно задавать при помощи свойства Person.prototype.\n" +
        "Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person. Его можно использовать, чтобы из самого объекта получить функцию, которая его создала. Однако, JavaScript никак не поддерживает корректность этого свойства, поэтому программист может его изменить или удалить.\n" +
        "Современный метод Object.create(proto) можно эмулировать при помощи prototype, если хочется, чтобы он работал в IE8-."
    },{
        h3:"Встроенные \"классы\" в JavaScript",
        p:"Методы встроенных объектов хранятся в их прототипах.\n" +
        "Встроенные прототипы можно расширить или поменять.\n" +
        "Добавление методов в Object.prototype, если оно не сопровождается Object.defineProperty с установкой enumerable (IE9+), «сломает» циклы for..in, поэтому стараются в этот прототип методы не добавлять.\n" +
        "Другие прототипы изменять менее опасно, но все же не рекомендуется во избежание конфликтов.\n" +
        "Отдельно стоит изменение с целью добавления современных методов в старые браузеры, таких как Object.create, Object.keys, Function.prototype.bind и т.п. Это допустимо и как раз делается es5-shim."
    },{
        h3:"Свои классы на прототипах",
        p:"Класс через прототип\n" +
        "А теперь создадим аналогичный класс, используя прототипы, наподобие того, как сделаны классы Object, Date и остальные.\n" +
        "Чтобы объявить свой класс, нужно:\n" +
        "Объявить функцию-конструктор.\n" +
        "Записать методы и свойства, нужные всем объектам класса, в prototype.\n" +
        "Достоинства\n" +
        "Функциональный стиль записывает в каждый объект и свойства и методы, а прототипный – только свойства. Поэтому прототипный стиль – быстрее и экономнее по памяти.\n" +
        "Недостатки\n" +
        "При создании методов через прототип, мы теряем возможность использовать локальные переменные как приватные свойства, у них больше нет общей области видимости с конструктором."
    },{
        h3:"Наследование классов в JavaScript",
        p:"Наследование на уровне объектов в JavaScript, как мы видели, реализуется через ссылку __proto__.\n" +
        "Теперь поговорим о наследовании на уровне классов, то есть когда объекты, создаваемые, к примеру, через new Admin, должны иметь все методы, которые есть у объектов, создаваемых через new User, и ещё какие-то свои.\n" +
        "Наследование Array от Object\n" +
        "Методы массивов Array хранятся в Array.prototype.\n" +
        "Array.prototype имеет прототипом Object.prototype.\n" +
        "Поэтому когда экземпляры класса Array хотят получить метод массива – они берут его из своего прототипа, например Array.prototype.slice.\n" +
        "Если же нужен метод объекта, например, hasOwnProperty, то его в Array.prototype нет, и он берётся из Object.prototype.\n" +
        "Для доступа к свойствам используют console.dir \n" +
        "Для наследования нужно, чтобы «склад методов потомка» (Child.prototype) наследовал от «склада метода родителей» (Parent.prototype).\n" +
        "Это можно сделать при помощи Object.create"
    },{
        h3:"Проверка класса: \"instanceof\"",
        p:"Оператор instanceof позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования\n" +
        "Алгоритм работы instanceof состоит в том, что \n" +
        "Вызов obj instanceof Constructor возвращает true, если объект принадлежит классу Constructor или классу, наследующему от него\n" +
        "Алгоритм проверки obj instanceof Constructor:\n" +
        "Получить obj.__proto__\n" +
        "Сравнить obj.__proto__ с Constructor.prototype\n" +
        "Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false).\n" +
        "Вообще, у каждого окна и фрейма – своя иерархия объектов и свой window .\n" +
        "Как правило, эта проблема возникает со встроенными объектами, в этом случае используется проверка внутреннего свойства [[Class]], которое подробнее описано в главе Типы данных: [[Class]], instanceof и утки."
    },{
        h3:"Свои ошибки, наследование от Error",
        p:"Чтобы наследовать от ошибок Error, нужно самостоятельно позаботиться о name, message и stack.\n" +
        "Благодаря тому, что instanceof поддерживает наследование, удобно организуются проверки на нужный тип. В иерархию ошибок можно в любой момент добавить новые классы, с понятным кодом и предсказуемым поведением.\n" +
        "Чтобы создавать наследники от Error было проще, можно создать класс CustomError, записать в него универсальный код, наподобие PropertyError и далее наследовать уже от него"
    },{
        h3:"Примеси",
        p:"В JavaScript невозможно унаследовать от двух и более объектов. Ссылка __proto__ – только одна.\n" +
        "Но потребность такая существует – к примеру, мы написали код, реализующий методы работы с шаблонизатором или методы по обмену событиями, и хочется легко и непринуждённо добавлять эти возможности к любому классу.\n" +
        "Обычно это делают через примеси.\n" +
        "Примесь (англ. mixin) – класс или объект, реализующий какое-либо чётко выделенное поведение. Используется для уточнения поведения других классов, не предназначен для самостоятельного использования.\n" +
        "Для добавления примеси в класс – её просто «подмешивают» в прототип.\n" +
        "«Подмешать» можно сколько угодно примесей, но если имена методов в разных примесях совпадают, то возможны конфликты. Их уже разрешать – разработчику. Например, можно заменить конфликтующий метод на свой, который будет решать несколько задач сразу. Конфликты при грамотно оформленных примесях возникают редко"
    }]
}, {
    h2: "Современные возможности ES-2015",
    p: [{
        h3:"ES-2015 сейчас",
        p:"Стандарт ES-2015 был принят в июне 2015. Пока что большинство браузеров реализуют его частично, текущее состояние реализации различных возможностей можно посмотреть здесь: https://kangax.github.io/compat-table/es6/.\n" +
        "Когда стандарт будет более-менее поддерживаться во всех браузерах, то весь учебник будет обновлён в соответствии с ним. Пока же, как центральное место для «сбора» современных фич JavaScript, создан этот раздел.\n" +
        "Чтобы писать код на ES-2015 прямо сейчас, есть следующие варианты.\n" +
        "Конкретный движок JS\n" +
        "Самое простое – это когда нужен один конкретный движок JS, например V8 (Chrome).\n" +
        "Тогда можно использовать только то, что поддерживается именно в нём. Заметим, что в V8 большинство возможностей ES-2015 поддерживаются только при включённом use strict.\n" +
        "При разработке на Node.JS обычно так и делают. Если же нужна кросс-браузерная поддержка, то этот вариант не подойдёт.\n" +
        "Babel.JS\n" +
        "Babel.JS – это транспайлер, переписывающий код на ES-2015 в код на предыдущем стандарте ES5.\n" +
        "Он состоит из двух частей:\n" +
        "Собственно транспайлер, который переписывает код.\n" +
        "Полифилл, который добавляет методы Array.from, String.prototype.repeat и другие.\n" +
        "На странице https://babeljs.io/repl/ можно поэкспериментировать с транспайлером: слева вводится код в ES-2015, а справа появляется результат его преобразования в ES5.\n" +
        "Обычно Babel.JS работает на сервере в составе системы сборки JS-кода (например webpack или brunch) и автоматически переписывает весь код в ES5.\n" +
        "Настройка такой конвертации тривиальна, единственно – нужно поднять саму систему сборки, а добавить к ней Babel легко, плагины есть к любой из них"
    },{
        h3:"Переменные: let и const",
        p:"В ES-2015 предусмотрены новые способы объявления переменных: через let и const вместо var.\n" +
        "У объявлений переменной через let есть три основных отличия от var:\n" +
        "\n" +
        "1.Область видимости переменной let – блок {...}.\n" +
        "\n" +
        "Как мы помним, переменная, объявленная через var, видна везде в функции.\n" +
        "\n" +
        "Переменная, объявленная через let, видна только в рамках блока {...}, в котором объявлена.\n" +
        "\n" +
        "Это, в частности, влияет на объявления внутри if, while или for.\n" +
        "Объявление const задаёт константу, то есть переменную, которую нельзя менять\n" +
        "Заметим, что если в константу присвоен объект, то от изменения защищена сама константа, но не свойства внутри неё"
    },{
        h3:"Деструктуризация",
        p:"Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части\n" +
        "Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора \"...\" («spread», троеточие\n" +
        "Если значений в массиве меньше, чем переменных – ошибки не будет, просто присвоится undefined"
    },{
        h3:"Функции",
        p:""
    },{
        h3:"Строки",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    },{
        h3:"",
        p:""
    }]
}
];

//myCode
var li = document.querySelectorAll("li");
var contentBarContainer = document.querySelector("#contentBar");

for (var i = 0; i < li.length; i++) {
    (function (a, iterator) {
        a.onclick = function () {
            /**
             * Clear element before appending new child
             */
            while (contentBarContainer.firstChild) {
                contentBarContainer.removeChild(contentBarContainer.firstChild);
            }
            var fragment = document.createDocumentFragment();
            createHtmlAssembly(myText[iterator], fragment);
            if (Array.isArray(myText[iterator].p) === true) {
                for (var alternative = 0; alternative < myText[iterator].p.length; alternative++) {
                    createHtmlAssembly(myText[iterator].p[alternative], fragment);
                }
            }
            contentBarContainer.appendChild(fragment);
        }
    }(li[i], i));
};
function createHtmlElement (tag, text) {
    var elem = document.createElement(tag);
    elem.innerHTML = text;
    return elem;
};
function createHtmlAssembly (tagName, fragment) {
    for (elem in tagName) {
        if (Array.isArray(tagName[elem]) === false) {
            fragment.appendChild(createHtmlElement(elem, tagName[elem]));
        }
    };
};
