var myText = [{
    h2: 'Введение',
    p: [{
        h3: 'Введение в JavaScript',
        p: '1.Введение в JavaScript дает нам общее понятие о создании, общей истории и развити JavaScript'
    }, {
        h3: 'Справочники и спецификации',
        p: '2.Подраздел справочники и спецификации дает нам информацию о том, какие особенности у каких браузеров и где можно найти корректную документацию касаемо JavaScript'

    }, {
        h3: 'Редакторы для кода',
        p: '3.В пункте Редакторы для кода нам представляется возможность ознакомиться с редакторами кода и ссылками на оф. страницы для скачивания.'

    }, {

        h3: "Консоль разработчика",
        p: "4.Пункт Консоль разработчика в кратце рассказывает нам на что стоит обратить внимание при проверке кода через консоль."
    }]
}, {
    h2: "Основы JavaScript",
    p: [{

        h3: "Привет мир!",
        p: "В данной статье нас знакомяс с особенностями месторасположения тега script и корректным размещением коментариев и тд."

    }, {
        h3: "Внешние скрипты, порядок исполнения",
        p: "Данная статья обучает нас подключению внешних скриптов и корректирует нас в их особенностях и различиях при загрузке на страницу а так же рассказывает, как они непосредственно влияют на саму загрузку страницы"

    }, {
        h3: "Структура кода ",
        p: "Данная статья обучит нас как корректнее делать разметку кода, переносы и разбитие на строки"

    }, {
        h3: "Современный стандарт, use strict",
        p: "Use strict строка- дает нам возможность писать более современный код, но в то же время имеет свои особенности в использовании..."

    }, {
        h3: "Переменные",
        p: "На мой взгляд-одна из важнейших статей в данном разделе! Благодаря ей мы более детально поймем как работать с переменными, заполнять их информацией и использовать ее в будущем."

    }, {
        h3: "Правильный выбор имени переменной",
        p: "Правильный выбор имени переменных-одно из основных базовых  пониманий того, что в ней будет храниться либо для чего она может быть использована"

    }, {
        h3: "Шесть типов данных, typeof",
        p: "В данной статье нас в кратце ознакамливают с 5 основными примитивными  типами данных и обьектами"

    }, {
        h3: "Операторы",
        p: "Исходя из школьных программ все мы помним про математические елементы вычисления. Но в данной статье афтор открывает нам их новые возможности и раскрывает секреты использования в програмировании"

    }, {
        h3: "Условные операторы: if,?",
        p: "Данная статья обучает нас различиям методов использования операторов а так же дает нам возможность понять, как грамотно выстроить логическую цепочку действий при различных ответах(либо без них)."

    }, {
        h3: "Функции",
        p: "Данный ряд статей нам рассказывает о том, как грамотно создавать и использовать функции и с их помощью делать клиентскую сторону более динамичной."
    }]
}, {
    h2: "Качество кода",
    p: [{
        h3: "Отладка в chrome",
        p: "В данном пункте нам рассказывается о корректном тестировании кода, его шифровании и отладке в браузере. О том, куда стоит обратить внимание при работе с данным браузером."
    }, {
        h3: "Советы по стилю кода",
        p: "Мы переходим к стилю кода и его корректному написанию. В этом разделе нам предоставят таблицу со всеми нареканиями и замечаниями которые могут навредить нашему написанию кода и его формированию(дальнейшему использованию) на странице"
    }, {
        h3: "Как писать неподдерживаемый код?",
        p: "Для написания неподдерживаемого кода нужно усложнить его понятность для окружающих(уловки на эту тему указаны в данном разделе) а так же нам дается краткая екскурсия того, как этот код писать так, чтоб он был понятен только вам"
    }, {
        h3: "Автоматические тесты при помощи chai и mocha",
        p: "С данной главой я рекомендовал бы ознакомиться в начале своей деятельности как програмиста. Ведь писочницу можно использовать как тесты (которые гарантируют правильность кода),документацию по функциям и описанию их конкретных задач"
    }]
}, {
    h2: "Структуры данных",
    p: [{
        h3: "Введение в методы и свойства",
        p: "Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку». К примеру .length укажет нам длинну масива а str.toUpperCase() вернет строку в ВЕРХНЕМ РЕГИСТРЕ, num.toFixed(n) округлитель чисел в котором num-число а n количество цифр после запятой"
    }, {
        h3:"Числа",
        p:"Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа, В JavaScript существует числовое значение бесконечность Infinity.\n" +
        "Ошибка вычислений дает NaN Есть четыре способа округления: Math.floor, Math.round, Math.ceil и битовый оператор. Для округления до нужного знака используйте +n.toFixed(p) или трюк с умножением и делением на 10p"
    },{
        h3:"Строки",
        p:"\\b\tBackspace\n" +
        "\\f\tForm feed\n" +
        "\\n\tNew line\n" +
        "\\r\tCarriage return\n" +
        "\\t\tTab" +
        "Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний" +
        "Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция])"
    },{
        h3:"Обьекты как ассоциальные массивы",
        p:"Доступ к элементам осуществляется:\n" +
		"Напрямую по ключу obj.prop = 5\n" +
		"Через переменную, в которой хранится ключ\n" +
		"Удаление ключей: delete obj.name"
    },{
        h3:"Объекты: перебор свойств",
        p:"Цикл по ключам: for (key in obj)\n" +
		"Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах)\n" +
		"Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +"
    },{
        h3:"Объекты: передача по ссылке",
        p:"Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.\n" +
		"Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.\n" +
		"Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью."
    },{
        h3:"Массивы с числовыми индексами",
        p:"length – длина массива. Если точнее, то последний индекс массива плюс 1. Если её уменьшить вручную, то массив укоротится. Если length больше реального количества элементов, то отсутствующие элементы равны undefined \n" +
		"arr.push(элемент1, элемент2...) добавляет элементы в конец. \n" +
		"var elem = arr.pop() удаляет и возвращает последний элемент \n" +
		"arr.unshift(элемент1, элемент2...) добавляет элементы в начало. \n" +
		"var elem = arr.shift() удаляет и возвращает первый элемент \n" +
		"Эти операции перенумеровывают все элементы, поэтому работают медленно"
    },{
        h3:"Массивы: методы",
        p:"push/pop, shift/unshift, splice – для добавления и удаления элементов.\n" +
		"join/split – для преобразования строки в массив и обратно.\n" +
		"slice – копирует участок массива.\n" +
		"sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.\n" +
		"reverse – меняет порядок элементов на обратный.\n" +
		"concat – объединяет массивы.\n" +
		"indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8-).\n" +
		"Дополнительно: Object.keys(arr) возвращает массив свойств объекта."
    },{
		h3:"Массив: перебирающие методы",
		p:"forEach – для перебора массива.\n" +
		"filter – для фильтрации массива.\n" +
		"every/some – для проверки массива.\n" +
		"map – для трансформации массива в массив.\n" +
		"reduce/reduceRight – для прохода по массиву с вычислением значения."
	},{
		h3:"Псевдомассив аргументов(arguments)",
		p:"Полный список аргументов, с которыми вызвана функция, доступен через arguments.\n" +
        "Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет.\n" +
        "В старом стандарте было свойство arguments.callee со ссылкой на текущую функцию, а также свойство arguments.callee.caller, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при use strict обращение к ним приведёт к ошибке.\n" +
        "Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||."
	},{
		h3:"Дата и Время",
		p:"new Date(year, month, date, hours, minutes, seconds, ms)\n" +
        "Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице\n" +
        "Получение компонентов даты\n" +
        "\n" +
        "Для доступа к компонентам даты-времени объекта Date используются следующие методы:\n" +
        "\n" +
        "getFullYear()\n" +
        "Получить год (из 4 цифр)\n" +
        "getMonth()\n" +
        "Получить месяц, от 0 до 11.\n" +
        "getDate()\n" +
        "Получить число месяца, от 1 до 31.\n" +
        "getHours(), getMinutes(), getSeconds(), getMilliseconds()\n" +
        "Получить соответствующие компоненты.\n" +
        "getDay()\n" +
        "Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).\n" +
        "Все методы, указанные выше, возвращают результат для местной временной зоны.\n" +
        "Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после get вставляется UTC.\n" +
        "Установка компонентов даты\n" +
        "\n" +
        "Следующие методы позволяют устанавливать компоненты даты и времени:\n" +
        "\n" +
        "setFullYear(year [, month, date])\n" +
        "setMonth(month [, date])\n" +
        "setDate(date)\n" +
        "setHours(hour [, min, sec, ms])\n" +
        "setMinutes(min [, sec, ms])\n" +
        "setSeconds(sec [, ms])\n" +
        "setMilliseconds(ms)\n" +
        "setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)\n" +
        "console.time(метка) – включить внутренний хронометр браузера с меткой.\n" +
        "console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.\n" +
        "Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date (кроме IE8-)\n" +
        "Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее."
	}]
}, {
    h2: "Замыкания",
    p:[{
        h3: "Глобальный объект",
        p: "Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные»\n" +
        "в глобальных обьектах Фигурные скобки, которые используются в for, while, if, в отличие от объявлений функции, имеют «декоративный» характер\n" +
        "В результате инициализации, к началу выполнения кода:\n" +
        "Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.\n" +
        "Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них."
    },{
        h3: "Замыкания, функции изнутри",
        p: "Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.\n" +
        "\n" +
        "Мы будем называть этот объект «лексическое окружение» или просто «объект переменных».\n" +
        "\n" +
        "При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.\n" +
        "\n" +
        "В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.\n" +
        "Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window.\n" +
        "При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.\n" +
        "Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.\n" +
        "\n" +
        "Таково стандартное определение, которое есть в Wikipedia и большинстве серьёзных источников по программированию. То есть, замыкание – это функция + внешние переменные.\n" +
        "\n" +
        "Тем не менее, в JavaScript есть небольшая терминологическая особенность.\n" +
        "\n" +
        "Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные.\n" +
        "\n" +
        "Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных."
    },{
        h3: "[[Scope]] для new Function",
        p: "При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.\n" +
        "Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров."
    },{
        h3: "Локальные переменные для объекта",
        p: "getNext() – получить следующее значение, то, что раньше делал вызов counter().\n" +
        "set(value) – поставить значение.\n" +
        "reset() – обнулить счётчик\n" +
        "ПРИМЕР :counter.set(5);\n" +
        "alert( counter() ); // 5"
    },{
        h3: "Модули через замыкания",
        p: "на месте» разрешено вызывать только Function Expression.\n" +
        "\n" +
        "Общее правило таково:\n" +
        "\n" +
        "Если браузер видит function в основном потоке кода – он считает, что это Function Declaration.\n" +
        "Если же function идёт в составе более сложного выражения, то он считает, что это Function Expression.\n" +
        "Для этого нужно завернуть функцию в скобки и браузер поймет , что у нас Function Expression, который по правилам JavaScript можно вызвать «на месте»." +
        "Можно показать это другим способом, например поставив перед функцией оператор \"+\" или \"!\" перед функцией" +
        "Модуль при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется.\n" +
        "Все функции модуля будут иметь доступ к другим переменным и внутренним функциям этого же модуля через замыкание.\n" +
        "Например, defaults из примера выше имеет доступ к assignDefaults.\n" +
        "Но снаружи программист, использующий модуль, может обращаться напрямую только к тем переменным и функциям, которые экспортированы. Благодаря этому будут скрыты внутренние аспекты реализации, которые нужны только разработчику модуля.\n" +
        "Можно придумать и много других вариаций такого подхода. В конце концов, «модуль» – это всего лишь функция-обёртка для скрытия переменных."
    },{
        h3: "Управление памятью в JavaScript",
        p: "Для очистки памяти от недостижимых значений в браузерах используется автоматический Сборщик мусора (англ. Garbage collection, GC), встроенный в интерпретатор, который наблюдает за объектами и время от времени удаляет недостижимые\n" +
        "Есть одно упрощение для работы с памятью: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка».\n" +
        "Верно – в том плане, что если ссылок на значение нет, то память из-под него очищается.\n" +
        "Неверно – в другую сторону: наличие ссылки не гарантирует, что значение останется в памяти.\n" +
        "Такая ситуация возникает с объектами, которые ссылаются друг на друга:\n" +
        "var vasya = {};\n" +
        "var petya = {};\n" +
        "vasya.friend = petya;\n" +
        "petya.friend = vasya;\n" +
        "vasya = petya = null;"
    },{
        h3: "Устаревшая конструкция \"with\"",
        p: "Свойства из разных объектов используются как обычные переменные… Магия! Порядок поиска переменных в выделенном коде: size => obj => window.\n" +
        "При использовании with, как и во вложенных функциях – переменная изменяется в той области, где была найдена.\n" +
        "Вместо with рекомендуется использовать временную переменную\n" +
        "Конструкция with(obj) { ... } использует obj как дополнительную область видимости. Все переменные, к которым идет обращение внутри блока, сначала ищутся в obj.\n" +
        "Конструкция with устарела и не рекомендуется по ряду причин. Избегайте её."
    }]
}, {
    h2: "Методы объектов и контекст вызова",
    p: [{
        h3:"Методы объектов, this",
        p: "Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана.\n" +
        "Через this метод может не только обратиться к любому свойству объекта, но и передать куда-то ссылку на сам объект целиком\n" +
        "Любая функция может иметь в себе this. Совершенно неважно, объявлена ли она в объекте или отдельно от него.\n" +
        "Значение this называется контекстом вызова и будет определено в момент вызова функции.\n" +
        "Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this\n" +
        "Если функция использует this – это подразумевает работу с объектом. Но и прямой вызов func() технически возможен.\n" +
        "Как правило, такая ситуация возникает при ошибке в разработке.\n" +
        "При этом this получает значение window, глобального объекта\n" +
        "А в режиме use strict вместо глобального объекта this будет undefined\n" +
        "Контекст this никак не привязан к функции, даже если она создана в объявлении объекта. Чтобы this передался, нужно вызвать функцию именно через точку (или квадратные скобки).\n" +
        "Любой более хитрый вызов приведёт к потере контекста"
    },{
        h3:"Преобразование объектов: toString и valueOf",
        p:"Строковое преобразование – если объект выводится через alert(obj).\n" +
        "Результатом toString может быть любой примитив\n" +
        "Метод toString не обязан возвращать именно строку.\n" +
        "Его результат может быть любого примитивного типа. Например, это может быть число если обьект преобразования имеет числовые индексы\n" +
        "Численное преобразование – при арифметических операциях, сравнении с примитивом.\n" +
        "Для численного преобразования объекта используется метод valueOf, а если его нет – то toString\n" +
        "Логическое преобразование – при if(obj) и других логических операциях. И приравнивается к true\n" +
        "Проще всего – с логическим преобразованием.\n" +
        "Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}\n" +
        "Две стадии преобразования\n" +
        "Объект Date, по историческим причинам, является исключением.\n" +
        "Бинарный оператор плюс + обычно использует числовое преобразование и метод valueOf. Как мы уже знаем, если подходящего valueOf нет (а его нет у большинства объектов), то используется toString, так что в итоге преобразование происходит к строке. Но если есть valueOf, то используется valueOf.\n" +
        "У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.\n" +
        "…Но оператор + для Date использует именно toString (хотя должен бы valueOf).\n" +
        "Это и есть исключение\n" +
        "В JavaScript вызовы new Boolean/String/Number не используются, а используются простые вызовы соответствующих функций, они преобразуют значение в примитив нужного типа, например Boolean(val) === !!val."
    },{
        h3:"Создание объектов через \"new\"",
        p:"Обычный синтаксис {...} позволяет создать один объект. Но зачастую нужно создать много однотипных объектов.\n" +
        "Для этого используют «функции-конструкторы», запуская их при помощи специального оператора new.\n" +
        "Заметим, что, технически, любая функция может быть использована как конструктор. То есть, любую функцию можно вызвать при помощи new. Как-то особым образом указывать, что она – конструктор – не надо.\n" +
        "Но, чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal.\n" +
        "Детальнее – функция, запущенная через new, делает следующее:\n" +
        "Создаётся новый пустой объект.\n" +
        "Ключевое слово this получает ссылку на этот объект.\n" +
        "Функция выполняется. Как правило, она модифицирует this (т.е. этот новый объект), добавляет методы, свойства.\n" +
        "Возвращается this.\n" +
        "Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом.\n" +
        "Но если явный вызов return всё же есть, то применяется простое правило:\n" +
        "При вызове return с объектом, будет возвращён он, а не this.\n" +
        "При вызове return с примитивным значением, оно будет отброшено.\n" +
        "Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this\n" +
        "Кстати, при вызове new без аргументов скобки можно не ставить(НО ЭТО БУДЕТ ЯВЛЯТЬСЯ ПЛОХИМ СТИЛЕМ НАПИСАНИЯ КОДА)"
    },{
        h3:"Дескрипторы, геттеры и сеттеры свойств",
        p:"Основной метод для управления свойствами – Object.defineProperty.\n" +
        "Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.\n" +
        "Синтаксис:\n" +
        "Object.defineProperty(obj, prop, descriptor)\n" +
        "Аргументы:\n" +
        "obj\n" +
        "Объект, в котором объявляется свойство.\n" +
        "prop\n" +
        "Имя свойства, которое нужно объявить или модифицировать.\n" +
        "descriptor\n" +
        "Дескриптор – объект, который описывает поведение свойства.\n" +
        "В нём могут быть следующие поля:\n" +
        "value – значение свойства, по умолчанию undefined\n" +
        "writable – значение свойства можно менять, если true. По умолчанию false.\n" +
        "configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.\n" +
        "enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.\n" +
        "get – функция, которая возвращает значение свойства. По умолчанию undefined.\n" +
        "set – функция, которая записывает значение свойства. По умолчанию undefined.\n" +
        "Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.\n" +
        "Для того, чтобы сделать свойство неизменяемым, изменим его флаги writable и configurable:\n" +
        "Заметим, что без use strict операция записи «молча» не сработает. Лишь если установлен режим use strict, то дополнительно сгенерируется ошибка.\n" +
        "Свойство, скрытое для for…in\n" +
        "Встроенный метод toString, как и большинство встроенных методов, не участвует в цикле for..in. Это удобно, так как обычно такое свойство является «служебным».\n" +
        "К сожалению, свойство toString, объявленное обычным способом, будет видно в цикле for..in\n" +
        "Object.keys(obj), Object.getOwnPropertyNames(obj)\n" +
        "Возвращают массив – список свойств объекта.\n" +
        "Object.keys возвращает только enumerable-свойства.\n" +
        "Object.getOwnPropertyNames – возвращает все:\n" +
        "Object.getOwnPropertyDescriptor(obj, prop)\n" +
        "Возвращает дескриптор для свойства obj[prop].\n" +
        "Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений\n" +
        "…И несколько методов, которые используются очень редко:\n" +
        "Object.preventExtensions(obj)\n" +
        "Запрещает добавление свойств в объект.\n" +
        "Object.seal(obj)\n" +
        "Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.\n" +
        "Object.freeze(obj)\n" +
        "Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.\n" +
        "Object.isExtensible(obj)\n" +
        "Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.\n" +
        "Object.isSealed(obj)\n" +
        "Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.\n" +
        "Object.isFrozen(obj)\n" +
        "Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.\n"
    },{
        h3:"Статические и фабричные методы",
        p:"Преимущества использования фабричных методов:\n" +
        "\n" +
        "Лучшая читаемость кода. Как конструктора – вместо одной большой функции несколько маленьких, так и вызывающего кода – явно видно, что именно создаётся.\n" +
        "Лучший контроль ошибок, т.к. если в createFromData ничего не передали, то будет ошибка, а полиморфный конструктор создал бы анонимного посетителя.\n" +
        "Удобная расширяемость. Например, нужно добавить создание администратора, без аргументов. Фабричный метод сделать легко: User.createAdmin = function() { ... }. А для полиморфного конструктора вызов без аргумента создаст анонима, так что нужно добавить параметр – «тип посетителя» и усложнить этим код.\n" +
        "Поэтому полиморфные конструкторы лучше использовать там, где нужен именно полиморфизм, т.е. когда непонятно, какого типа аргумент передадут, и хочется в одном конструкторе охватить все варианты.\n" +
        "А в остальных случаях отличная альтернатива – фабричные методы.\n" +
        "Статические свойства и методы объекта удобно применять в следующих случаях:\n" +
        "Общие действия и подсчёты, имеющие отношения ко всем объектам данного типа. В примерах выше это подсчёт количества.\n" +
        "Методы, не привязанные к конкретному объекту, например сравнение.\n" +
        "Вспомогательные методы, которые полезны вне объекта, например для форматирования даты."
    },{
        h3:"Явное указание this: \"call\", \"apply\"",
        p:"При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.\n" +
        "Это называется «одалживание метода» (на англ. method borrowing).\n" +
        "Используем эту технику для упрощения манипуляций с arguments.\n" +
        "Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет.\n" +
        "Метод apply\n" +
        "Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply.\n" +
        "Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка\n" +
        "Значение this устанавливается в зависимости от того, как вызвана функция:\n" +
        "При вызове функции как метода:\n" +
        "obj.func(...)    // this = obj\n" +
        "obj[\"func\"](...)\n" +
        "При обычном вызове:\n" +
        "func(...) // this = window (ES3) /undefined (ES5)\n" +
        "В new:\n" +
        "new func() // this = {} (новый объект)\n" +
        "Явное указание:\n" +
        "func.apply(context, args) // this = context (явная передача)\n" +
        "func.call(context, arg1, arg2, ...)"
    },{
        h3:"Привязка контекста и карринг: \"bind\"",
        p:"Функция сама по себе не запоминает контекст выполнения.\n" +
        "\n" +
        "Чтобы гарантировать правильный контекст для вызова obj.func(), нужно использовать функцию-обёртку, задать её через анонимную функцию:\n" +
        "\n" +
        "setTimeout(function() {\n" +
        "  obj.func();\n" +
        "})\n" +
        "…Либо использовать bind:\n" +
        "\n" +
        "setTimeout(obj.func.bind(obj));\n" +
        "Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.\n" +
        "\n" +
        "Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз."
    },{
        h3:"Функции-обёртки, декораторы",
        p:"Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.\n" +
        "Декораторы можно не только повторно использовать, но и комбинировать!\n" +
        "Это кардинально повышает их выразительную силу. Декораторы можно рассматривать как своего рода «фичи» или возможности, которые можно «нацепить» на любую функцию. Можно один, а можно несколько.\n" +
        "Скажем, используя декораторы, описанные выше, можно добавить к функции возможности по проверке типов данных, замеру времени и проверке доступа буквально одной строкой, не залезая при этом в её код, то есть (!) не увеличивая его сложность.\n" +
        "Предлагаю вашему вниманию задачи, которые помогут выяснить, насколько вы разобрались в декораторах. Далее в учебнике мы ещё встретимся с ними."
    }]
}, {
    h2: "Некторорые другие возможности",
    p: [{
        h3:"Типы данных: [[Class]], instanceof и утки",
        p:" Секретное свойство [[Class]]\n" +
        "Для встроенных объектов есть одна «секретная» возможность узнать их тип, которая связана с методом toString.\n" +
        "Во всех встроенных объектах есть специальное свойство [[Class]], в котором хранится информация о его типе или конструкторе.\n" +
        "Оно взято в квадратные скобки, так как это свойство – внутреннее. Явно получить его нельзя, но можно прочитать его «в обход», воспользовавшись методом toString стандартного объекта Object.\n" +
        "Его внутренняя реализация выводит [[Class]] в небольшом обрамлении, как \"[object значение]\".\n" +
        "Оператор instanceof позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.\n" +
        "Для написания полиморфных (это удобно!) функций нам нужна проверка типов.\n" +
        "Для примитивов с ней отлично справляется оператор typeof.\n" +
        "У него две особенности:\n" +
        "Он считает null объектом, это внутренняя ошибка в языке.\n" +
        "Для функций он возвращает function, по стандарту функция не считается базовым типом, но на практике это удобно и полезно.\n" +
        "Для встроенных объектов мы можем получить тип из скрытого свойства [[Class]], при помощи вызова {}.toString.call(obj).slice(8, -1). Для конструкторов, которые объявлены нами, [[Class]] всегда равно \"Object\".\n" +
        "Оператор obj instanceof Func проверяет, создан ли объект obj функцией Func, работает для любых конструкторов. Более подробно мы разберём его в главе Проверка класса: \"instanceof\".\n" +
        "И, наконец, зачастую достаточно проверить не сам тип, а просто наличие нужных свойств или методов. Это называется «утиная типизация»."
    },{
        h3:"Формат JSON, метод toJSON",
        p:" Данные в формате JSON (RFC 4627) представляют собой:\n" +
        "\n" +
        "JavaScript-объекты { ... } или\n" +
        "Массивы [ ... ] или\n" +
        "Значения одного из типов:\n" +
        "строки в двойных кавычках,\n" +
        "число,\n" +
        "логическое значение true/false,\n" +
        "null.\n" +
        " Основные методы для работы с JSON в JavaScript – это:\n" +
        "JSON.parse – читает объекты из строки в формате JSON.\n" +
        "JSON.stringify – превращает объекты в строку в формате JSON, используется, когда нужно из JavaScript передать данные по сети.\n" +
        " Вызов JSON.parse(str) превратит строку с данными в формате JSON в JavaScript-объект/массив/значение.\n" +
        "Объекты в формате JSON похожи на обычные JavaScript-объекты, но отличаются от них более строгими требованиями к строкам – они должны быть именно в двойных кавычках.\n" +
        "Кроме того, в формате JSON не поддерживаются комментарии. Он предназначен только для передачи данных.\n" +
        "Есть нестандартное расширение формата JSON, которое называется JSON5 и как раз разрешает ключи без кавычек, комментарии и т.п, как в обычном JavaScript. На данном этапе это отдельная библиотека.\n" +
        " Метод JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.\n" +
        "При сериализации объекта вызывается его метод toJSON.\n" +
        "Если такого метода нет – перечисляются его свойства, кроме функций.\n" +
        "Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод toJSON. Его результат в данном случае – строка в таймзоне UTC.\n"
    },{
        h3:"setTimeout и setInterval",
        p:" Методы setInterval(func, delay) и setTimeout(func, delay) позволяют запускать func регулярно/один раз через delay миллисекунд.\n" +
        "Оба метода возвращают идентификатор таймера. Его используют для остановки выполнения вызовом clearInterval/clearTimeout.\n" +
        "В случаях, когда нужно гарантировать задержку между регулярными вызовами или гибко её менять, вместо setInterval используют рекурсивный setTimeout.\n" +
        "Минимальная задержка по стандарту составляет 4 мс. Браузеры соблюдают этот стандарт, но некоторые другие среды для выполнения JS, например Node.JS, могут предоставить и меньше задержки.\n" +
        "В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.\n" +
        "Браузерных особенностей почти нет, разве что вызов setInterval(..., 0) с нулевой задержкой в IE недопустим, нужно указывать setInterval(..., 1)."
    },{
        h3:"Запуск кода из строки: eval",
        p:" Функция eval(code) позволяет выполнить код, переданный ей в виде строки.\n" +
        "Этот код будет выполнен в текущей области видимости.\n" +
        "При вызове eval имеет полный доступ к локальным переменным.\n" +
        "Это означает, что текущие переменные могут быть изменены или дополнены\n" +
        " В строгом режиме eval имеет свою область видимости\n" +
        "В строгом режиме функционал eval чуть-чуть меняется.\n" +
        "При use strict код внутри eval по-прежнему сможет читать и менять внешние переменные, однако переменные и функции, объявленные внутри eval, не попадут наружу\n" +
        "Неграмотное использование eval\n" +
        "Начнём с того, что eval применяется очень редко. Действительно редко. Есть даже такое выражение «eval is evil» (eval – зло).\n" +
        "Причина проста: когда-то JavaScript был гораздо более слабым языком, чем сейчас, и некоторые вещи без eval было сделать невозможно. Но те времена давно прошли. И теперь найти тот случай, когда действительно надо выполнить код из строки – это надо постараться.\n" +
        "Но если вы действительно знаете, что это именно тот случай и вам необходим eval – есть ряд вещей, которые нужно иметь в виду.\n" +
        "Доступ к локальным переменным – худшее, что можно сделать при eval.\n" +
        "Дело в том, что локальные переменные могут быть легко переименованы\n" +
        "JSON и eval\n" +
        "\n" +
        "В браузерах IE7- не было методов JSON.stringify и JSON.parse, поэтому работа с JSON происходила через eval.\n" +
        "\n" +
        "Этот способ работы с JSON давно устарел, но его можно встретить кое-где в старом коде, так что для примера рассмотрим его.\n" +
        "\n" +
        "Вызов eval(code) выполняет код и, если это выражение, то возвращает его значение, поэтому можно в качестве кода передать JSON.\n" +
        "Осторожно, злой JSON!\n" +
        "Если мы получаем JSON из недоверенного источника, например с чужого сервера, то разбор через eval может быть опасен.\n" +
        "\n" +
        "Например, чужой сервер может быть взломан (за свой-то код мы отвечаем, а за чужой – нет), и вместо JSON вставлен злонамеренный JavaScript-код.\n" +
        "\n" +
        "Поэтому рекомендуется, всё же, использовать JSON.parse.\n" +
        "\n" +
        "При разборе через JSON.parse некорректный JSON просто приведёт к ошибке, а вот при разборе через eval этот код реально выполнится, он может вывести что-то на странице, перенаправить посетителя куда-то и т.п.\n"
    },{
        h3:"Перехват ошибок, \"try..catch\"",
        p:" Обработка ошибок – большая и важная тема.\n" +
        "В JavaScript для этого предусмотрены:\n" +
        "Конструкция try..catch..finally – она позволяет обработать произвольные ошибки в блоке кода.\n" +
        "Это удобно в тех случаях, когда проще сделать действие и потом разбираться с результатом, чем долго и нудно проверять, не упадёт ли чего.\n" +
        "Кроме того, иногда проверить просто невозможно, например JSON.parse(str) не позволяет «проверить» формат строки перед разбором. В этом случае блок try..catch необходим.\n" +
        "Полный вид конструкции:\n" +
        "          try {\n" +
        "   .. пробуем выполнить код ..\n" +
        "} catch(e) {\n" +
        "   .. перехватываем исключение ..\n" +
        "} finally {\n" +
        "   .. выполняем всегда ..\n" +
        "}\n" +
        "Возможны также варианты try..catch или try..finally.\n" +
        "Оператор throw err генерирует свою ошибку, в качестве err рекомендуется использовать объекты, совместимые с встроенным типом Error, содержащие свойства message и name.\n" +
        "Кроме того, мы рассмотрели некоторые важные приёмы:\n" +
        "Проброс исключения – catch(err) должен обрабатывать только те ошибки, которые мы рассчитываем в нём увидеть, остальные – пробрасывать дальше через throw err.\n" +
        "Определить, нужная ли это ошибка, можно, например, по свойству name.\n" +
        "Оборачивание исключений – функция, в процессе работы которой возможны различные виды ошибок, может «обернуть их» в одну общую ошибку, специфичную для её задачи, и уже её пробросить дальше. Чтобы, при необходимости, можно было подробно определить, что произошло, исходную ошибку обычно присваивают в свойство этой, общей. Обычно это нужно для логирования.\n" +
        "В window.onerror можно присвоить функцию, которая выполнится при любой «выпавшей» из скрипта ошибке. Как правило, это используют в информационных целях, например отправляют информацию об ошибке на специальный сервис."
    }]
}, {
    h2: "ООП в функциональном стиле",
    p: [{
        h3:"Введение",
        p:"ООП – это не просто объекты\n" +
        "В JavaScript объекты часто используются просто как коллекции.\n" +
        "Например, встроенный объект Math содержит функции (Math.sin, Math.pow, …) и данные (константа Math.PI).\n" +
        "При таком использовании объектов мы не можем сказать, что «применён объектно-ориентированный подход». В частности, никакую «единую сущность» Math из себя не представляет, это просто коллекция независимых функций с общим префиксом Math.\n" +
        "Класс в ООП\n" +
        "Классом в объектно-ориентированной разработке называют шаблон/программный код, предназначенный для создания объектов и методов.\n" +
        "\n" +
        "В JavaScript классы можно организовать по-разному. Говорят, что класс User написан в «функциональном» стиле. Далее мы также увидим «прототипный» стиль"
    },{
        h3:"Внутренний и внешний интерфейс",
        p:" Внутренний и внешний интерфейс\n" +
        "В программировании мы будем разделять методы и свойства объекта на две группы:\n" +
        "Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).\n" +
        "Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными».\n" +
        "Шаг 1: публичное и приватное свойство\n" +
        "Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.\n" +
        "Свойстра, записанные в обьект и пригодны к внешнему изменению называются ПУБЛИЧНЫМИ СВОЙСТВАМИ\n" +
        "ШАГ 2\n" +
        ""
    },{
        h3:"Геттеры и сеттеры",
        p:" "
    },{
        h3:"Функциональное наследование",
        p:" "
    }]
}, {
    h2: "ООП в прототипном стиле"
}, {
    h2: "Современные возможности ES-2015",
    p: "Современные возможности ES-2015"
}
];

//myCode
var li = document.querySelectorAll("li");
var contentBarContainer = document.querySelector("#contentBar");

for (var i = 0; i < li.length; i++) {
    (function (a, iterator) {
        a.onclick = function () {
            /**
             * Clear element before appending new child
             */
            while (contentBarContainer.firstChild) {
                contentBarContainer.removeChild(contentBarContainer.firstChild);
            }
            var fragment = document.createDocumentFragment();
            createHtmlAssembly(myText[iterator], fragment);
            if (Array.isArray(myText[iterator].p) === true) {
                for (var alternative = 0; alternative < myText[iterator].p.length; alternative++) {
                    createHtmlAssembly(myText[iterator].p[alternative], fragment);
                }
            }
            contentBarContainer.appendChild(fragment);
        }
    }(li[i], i));
};
function createHtmlElement (tag, text) {
    var elem = document.createElement(tag);
    elem.innerHTML = text;
    return elem;
};
function createHtmlAssembly (tagName, fragment) {
    for (elem in tagName) {
        if (Array.isArray(tagName[elem]) === false) {
            fragment.appendChild(createHtmlElement(elem, tagName[elem]));
        }
    };
};
